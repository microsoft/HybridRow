// ------------------------------------------------------------
//  Copyright (c) Microsoft Corporation.  All rights reserved.
// ------------------------------------------------------------

// ------------------------------------------------------------
// This file was generated by:
//   Microsoft.Azure.Cosmos.Serialization.HybridRowCLI: 1.0.0.0
//
// This file should not be modified directly.
// ------------------------------------------------------------

#pragma warning disable NamespaceMatchesFolderStructure // Namespace Declarations must match folder structure.
#pragma warning disable CA1707 // Identifiers should not contain underscores.
#pragma warning disable CA1034 // Do not nest types.
#pragma warning disable CA2104 // Do not declare readonly mutable reference types.
#pragma warning disable SA1129 // Do not use default value type constructor.
#pragma warning disable SA1309 // Field should not begin with an underscore.
#pragma warning disable SA1310 // Field names should not contain underscore.
#pragma warning disable SA1402 // File may only contain a single type.
#pragma warning disable SA1414 // Tuple types in signatures should have element names.
#pragma warning disable SA1514 // Element documentation header should be preceded by blank line.
#pragma warning disable SA1516 // Elements should be separated by blank line.
#pragma warning disable SA1649 // File name should match first type name.

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantEmptySwitchSection
// ReSharper disable JoinDeclarationAndInitializer
// ReSharper disable TooWideLocalVariableScope
// ReSharper disable ArrangeStaticMemberQualifier
// ReSharper disable RedundantJumpStatement
// ReSharper disable RedundantUsingDirective
namespace Microsoft.Azure.Cosmos.Serialization.HybridRow.Schemas
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using Microsoft.Azure.Cosmos.Core;
    using Microsoft.Azure.Cosmos.Core.Utf8;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.IO;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.Layouts;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.RecordIO;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.Schemas;

    internal static class SchemasHrSchema
    {
        public static readonly Namespace Namespace = SchemasHrSchema.CreateSchema();
        public static readonly LayoutResolver LayoutResolver = SchemasHrSchema.LoadSchema();

        private static Namespace CreateSchema()
        {
            return new Namespace
            {
                Name = "Microsoft.Azure.Cosmos.Serialization.HybridRow.Schemas",
                Version = SchemaLanguageVersion.V2,
                CppNamespace = "cdb_hr",
                Enums = new List<EnumSchema>
                {
                    //////////////////////////////////////////////////////////////////////////////
                    new EnumSchema
                    {
                        Name = "SchemaLanguageVersion",
                        Comment = "Versions of the HybridRow Schema Description Language.",
                        Type = TypeKind.UInt8,
                        Values = new List<EnumValue>
                        {
                            new EnumValue
                            {
                                Name = "V1",
                                Comment = "Initial version of the HybridRow Schema Description Language.",
                                Value = 0,
                            },
                            new EnumValue
                            {
                                Name = "V2",
                                Comment = "Introduced Enums, Inheritance.",
                                Value = 2,
                            },
                            new EnumValue
                            {
                                Name = "Unspecified",
                                Comment = "No version is specified.",
                                Value = 255,
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new EnumSchema
                    {
                        Name = "TypeKind",
                        Comment = "Describes the logical type of a property.",
                        Type = TypeKind.UInt8,
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new EnumSchema
                    {
                        Name = "StorageKind",
                        Comment = "Describes the storage placement for primitive properties.",
                        Type = TypeKind.UInt8,
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new EnumSchema
                    {
                        Name = "SortDirection",
                        Comment = "Describes the sort order direction.",
                        Type = TypeKind.UInt8,
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new EnumSchema
                    {
                        Name = "AllowEmptyKind",
                        Comment = "Describes the empty canonicalization for properties.",
                        Type = TypeKind.UInt8,
                    },
                },
                Schemas = new List<Schema>
                {
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "EmptySchema",
                        SchemaId = new SchemaId(2147473650),
                        Options = new SchemaOptions
                        {
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "Segment",
                        SchemaId = new SchemaId(2147473648),
                        Options = new SchemaOptions
                        {
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "length",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int32,
                                    Storage = StorageKind.Fixed,
                                    RowBufferSize = true,
                                },
                                Comment = "(Required) length (in bytes) of this RecordIO segment header itself.  Does NOT include the length of the records that follow.",
                            },
                            new Property
                            {
                                Path = "comment",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "A comment describing the data in this RecordIO segment.",
                            },
                            new Property
                            {
                                Path = "sdl",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "A HybridRow Schema in SDL (json-format).",
                                ApiName = "SDL",
                            },
                            new Property
                            {
                                Path = "schema",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "Namespace",
                                    SchemaId = new SchemaId(2147473651),
                                },
                                Comment = "A HybridRow Schema.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "Record",
                        SchemaId = new SchemaId(2147473649),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "length",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int32,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                },
                                Comment = "(Required) length (in bytes) of the HybridRow value that follows this record header.",
                            },
                            new Property
                            {
                                Path = "crc32",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.UInt32,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                },
                                Comment = "(Optional) CRC-32 as described in ISO 3309.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "Namespace",
                        SchemaId = new SchemaId(2147473651),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "version",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "SchemaLanguageVersion",
                                    Nullable = false,
                                },
                                Comment = "(Required) SDL language version.",
                            },
                            new Property
                            {
                                Path = "name",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                                Comment = "(Optional) Name of the namespace.",
                            },
                            new Property
                            {
                                Path = "comment",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "(Optional) Comment field describing the namespace.",
                            },
                            new Property
                            {
                                Path = "schemas",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "Schema",
                                        SchemaId = new SchemaId(2147473652),
                                        Nullable = false,
                                    },
                                },
                                Comment = "The set of schemas that make up the namespace.",
                            },
                            new Property
                            {
                                Path = "enums",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "EnumSchema",
                                        SchemaId = new SchemaId(2147473668),
                                        Nullable = false,
                                    },
                                },
                                Comment = "The set of enums defined in the namespace.",
                            },
                            new Property
                            {
                                Path = "cppNamespace",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "An (optional) namespace to use when performing C++ codegen.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "Schema",
                        SchemaId = new SchemaId(2147473652),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "version",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "SchemaLanguageVersion",
                                    Nullable = false,
                                },
                                Comment = "(Optional) SDL language version.",
                            },
                            new Property
                            {
                                Path = "type",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "TypeKind",
                                    Nullable = false,
                                },
                                Comment = "(Required) Type of the schema element.",
                            },
                            new Property
                            {
                                Path = "id",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int32,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                    ApiType = "SchemaId",
                                },
                                Comment = "(Required) Globally unique id of the schema.",
                                ApiName = "SchemaId",
                            },
                            new Property
                            {
                                Path = "name",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                                Comment = "(Optional) Name of the schema.",
                            },
                            new Property
                            {
                                Path = "comment",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "(Optional) Comment field describing the schema.",
                            },
                            new Property
                            {
                                Path = "options",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "SchemaOptions",
                                    SchemaId = new SchemaId(2147473653),
                                },
                                Comment = "(Optional) Schema options.",
                            },
                            new Property
                            {
                                Path = "partitionKeys",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "PartitionKey",
                                        SchemaId = new SchemaId(2147473654),
                                        Nullable = false,
                                    },
                                },
                                Comment = "(Optional) List of zero or more logical paths that form the partition key.",
                            },
                            new Property
                            {
                                Path = "primaryKeys",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "PrimarySortKey",
                                        SchemaId = new SchemaId(2147473655),
                                        Nullable = false,
                                    },
                                },
                                Comment = "(Optional) List of zero or more logical paths that form the primary sort key.",
                            },
                            new Property
                            {
                                Path = "staticKeys",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "StaticKey",
                                        SchemaId = new SchemaId(2147473656),
                                        Nullable = false,
                                    },
                                },
                                Comment = "(Optional) List of zero or more logical paths that hold data shared by all documents that have the same partition key.",
                            },
                            new Property
                            {
                                Path = "properties",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "Property",
                                        SchemaId = new SchemaId(2147473657),
                                        Nullable = false,
                                    },
                                },
                                Comment = "(Optional) List of zero or more property definitions that define the columns within the schema.",
                            },
                            new Property
                            {
                                Path = "baseName",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "The name of the schema this schema derives from.",
                            },
                            new Property
                            {
                                Path = "baseId",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int32,
                                    ApiType = "SchemaId",
                                },
                                Comment = "The unique identifier of the schema this schema derives from.",
                                ApiName = "BaseSchemaId",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "SchemaOptions",
                        SchemaId = new SchemaId(2147473653),
                        Comment = "Describes the set of options that apply to the entire schema and the way it is validated.",
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "disallowUnschematized",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                },
                            },
                            new Property
                            {
                                Path = "enablePropertyLevelTimestamp",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                },
                            },
                            new Property
                            {
                                Path = "disableSystemPrefix",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                },
                            },
                            new Property
                            {
                                Path = "abstract",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                },
                                Comment = "If true then instances of this schema cannot be created directly, only through subtypes.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "PartitionKey",
                        SchemaId = new SchemaId(2147473654),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "path",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "PrimarySortKey",
                        SchemaId = new SchemaId(2147473655),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "path",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                            },
                            new Property
                            {
                                Path = "direction",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "SortDirection",
                                    Nullable = false,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "StaticKey",
                        SchemaId = new SchemaId(2147473656),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "path",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "Property",
                        SchemaId = new SchemaId(2147473657),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "path",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                            },
                            new Property
                            {
                                Path = "comment",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                            },
                            new Property
                            {
                                Path = "type",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "PropertyType",
                                    SchemaId = new SchemaId(2147473658),
                                },
                                Comment = "The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.",
                                ApiName = "PropertyType",
                            },
                            new Property
                            {
                                Path = "apiname",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                ApiName = "ApiName",
                            },
                            new Property
                            {
                                Path = "allowEmpty",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Enum = "AllowEmptyKind",
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "PropertyType",
                        SchemaId = new SchemaId(2147473658),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                            Abstract = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "apitype",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                                ApiName = "ApiType",
                            },
                            new Property
                            {
                                Path = "type",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "TypeKind",
                                    Nullable = false,
                                },
                            },
                            new Property
                            {
                                Path = "nullable",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "PrimitivePropertyType",
                        SchemaId = new SchemaId(2147473659),
                        BaseName = "PropertyType",
                        BaseSchemaId = new SchemaId(2147473658),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "length",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int32,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                },
                            },
                            new Property
                            {
                                Path = "storage",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "StorageKind",
                                    Nullable = false,
                                },
                            },
                            new Property
                            {
                                Path = "enum",
                                AllowEmpty = AllowEmptyKind.EmptyAsNull,
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                            },
                            new Property
                            {
                                Path = "rowBufferSize",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "ScopePropertyType",
                        SchemaId = new SchemaId(2147473660),
                        BaseName = "PropertyType",
                        BaseSchemaId = new SchemaId(2147473658),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                            Abstract = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "immutable",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Boolean,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "ArrayPropertyType",
                        SchemaId = new SchemaId(2147473661),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "items",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "PropertyType",
                                    SchemaId = new SchemaId(2147473658),
                                },
                                Comment = "The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "ObjectPropertyType",
                        SchemaId = new SchemaId(2147473662),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "properties",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "Property",
                                        SchemaId = new SchemaId(2147473657),
                                        Nullable = false,
                                    },
                                },
                                Comment = "(Optional) List of zero or more property definitions that define the columns within the schema.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "UdtPropertyType",
                        SchemaId = new SchemaId(2147473663),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "name",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                            },
                            new Property
                            {
                                Path = "id",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int32,
                                    Storage = StorageKind.Fixed,
                                    Nullable = false,
                                    ApiType = "SchemaId",
                                },
                                ApiName = "SchemaId",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "SetPropertyType",
                        SchemaId = new SchemaId(2147473664),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "items",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "PropertyType",
                                    SchemaId = new SchemaId(2147473658),
                                },
                                Comment = "The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "MapPropertyType",
                        SchemaId = new SchemaId(2147473665),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "keys",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "PropertyType",
                                    SchemaId = new SchemaId(2147473658),
                                },
                                Comment = "The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.",
                            },
                            new Property
                            {
                                Path = "values",
                                PropertyType = new UdtPropertyType
                                {
                                    Name = "PropertyType",
                                    SchemaId = new SchemaId(2147473658),
                                },
                                Comment = "The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "TuplePropertyType",
                        SchemaId = new SchemaId(2147473666),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "items",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "PropertyType",
                                        SchemaId = new SchemaId(2147473658),
                                        Nullable = false,
                                    },
                                },
                                Comment = "The type of the properties. This field is polymorphic and may contain any defined subtype of PropertyType.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "TaggedPropertyType",
                        SchemaId = new SchemaId(2147473667),
                        BaseName = "ScopePropertyType",
                        BaseSchemaId = new SchemaId(2147473660),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "items",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "PropertyType",
                                        SchemaId = new SchemaId(2147473658),
                                        Nullable = false,
                                    },
                                },
                                Comment = "The type of the properties. This field is polymorphic and may contain any defined subtype of PropertyType.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "EnumSchema",
                        SchemaId = new SchemaId(2147473668),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "type",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Enum,
                                    Storage = StorageKind.Fixed,
                                    Enum = "TypeKind",
                                    Nullable = false,
                                },
                                Comment = "(Required) Type of the schema element.",
                            },
                            new Property
                            {
                                Path = "name",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                                Comment = "(Optional) Name of the schema.",
                            },
                            new Property
                            {
                                Path = "comment",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "(Optional) Comment field describing the schema.",
                            },
                            new Property
                            {
                                Path = "apitype",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "Api-specific type annotations for the property.",
                                ApiName = "ApiType",
                            },
                            new Property
                            {
                                Path = "values",
                                AllowEmpty = AllowEmptyKind.Both,
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "EnumValue",
                                        SchemaId = new SchemaId(2147473669),
                                        Nullable = false,
                                    },
                                },
                                Comment = "(Optional) List of zero or more values.",
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "EnumValue",
                        SchemaId = new SchemaId(2147473669),
                        Options = new SchemaOptions
                        {
                            DisallowUnschematized = true,
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "name",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                                Comment = "(Optional) Name of the schema.",
                            },
                            new Property
                            {
                                Path = "value",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int64,
                                    Storage = StorageKind.Fixed,
                                },
                                Comment = "The numerical value of the enum value.",
                            },
                            new Property
                            {
                                Path = "comment",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                },
                                Comment = "(Optional) Comment field describing the schema.",
                            },
                        },
                    },
                },
            };
        }

        private static LayoutResolver LoadSchema()
        {
            return new LayoutResolverNamespace(SchemasHrSchema.Namespace);
        }
    }

    public readonly struct SegmentHybridRowSerializer : IHybridRowSerializer<Segment>
    {
        public const int SchemaId = 2147473648;
        public const int Size = 5;
        public IEqualityComparer<Segment> Comparer => SegmentComparer.Default;
        private static readonly Utf8String LengthName = Utf8String.TranscodeUtf16("length");
        private static readonly Utf8String CommentName = Utf8String.TranscodeUtf16("comment");
        private static readonly Utf8String SDLName = Utf8String.TranscodeUtf16("sdl");
        private static readonly Utf8String SchemaName = Utf8String.TranscodeUtf16("schema");

        private static readonly LayoutColumn LengthColumn;
        private static readonly LayoutColumn CommentColumn;
        private static readonly LayoutColumn SDLColumn;
        private static readonly LayoutColumn SchemaColumn;

        private static readonly StringToken CommentToken;
        private static readonly StringToken SDLToken;
        private static readonly StringToken SchemaToken;

        static SegmentHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(LengthName, out LengthColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CommentName, out CommentColumn);
            Contract.Invariant(found);
            found = layout.TryFind(SDLName, out SDLColumn);
            Contract.Invariant(found);
            found = layout.TryFind(SchemaName, out SchemaColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(CommentColumn.Path, out CommentToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(SDLColumn.Path, out SDLToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(SchemaColumn.Path, out SchemaToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, Segment value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, Segment value)
        {
            Result r;
            if (value.Comment != default)
            {
                scope.Find(ref row, CommentColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Comment);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.SDL != default)
            {
                scope.Find(ref row, SDLColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.SDL);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Schema != default)
            {
                scope.Find(ref row, SchemaColumn.Path);
                r = default(NamespaceHybridRowSerializer)
                    .Write(ref row, ref scope, false, SchemaColumn.TypeArgs, value.Schema);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            // Emit RowBufferSize field with actual size of RowBuffer.
            r = LayoutType.Int32.WriteFixed(ref row, ref scope, LengthColumn, row.Length);
            if (r != Result.Success)
            {
                return r;
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out Segment value)
        {
            if (isRoot)
            {
                value = new Segment();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new Segment();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref Segment value)
        {
            Result r;
            {
                r = LayoutType.Int32.ReadFixed(ref row, ref scope, LengthColumn, out int fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Length = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == CommentToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Comment = fieldValue;
                    continue;
                }

                if (scope.Token == SDLToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.SDL = fieldValue;
                    continue;
                }

                if (scope.Token == SchemaToken.Id)
                {
                    r = default(NamespaceHybridRowSerializer)
                        .Read(ref row, ref scope, false, out Namespace fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Schema = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class SegmentComparer : EqualityComparer<Segment>
        {
            public static new readonly SegmentComparer Default = new SegmentComparer();

            public override bool Equals(Segment x, Segment y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Int32HybridRowSerializer).Comparer.Equals(x.Length, y.Length) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Comment, y.Comment) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.SDL, y.SDL) && 
                    default(NamespaceHybridRowSerializer).Comparer.Equals(x.Schema, y.Schema);
            }

            public override int GetHashCode(Segment obj)
            {
                return HashCode.Combine(
                    default(Int32HybridRowSerializer).Comparer.GetHashCode(obj.Length),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Comment),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.SDL),
                    default(NamespaceHybridRowSerializer).Comparer.GetHashCode(obj.Schema));
            }
        }
    }

    public readonly struct RecordHybridRowSerializer : IHybridRowSerializer<Record>
    {
        public const int SchemaId = 2147473649;
        public const int Size = 8;
        public IEqualityComparer<Record> Comparer => RecordComparer.Default;
        private static readonly Utf8String LengthName = Utf8String.TranscodeUtf16("length");
        private static readonly Utf8String Crc32Name = Utf8String.TranscodeUtf16("crc32");

        private static readonly LayoutColumn LengthColumn;
        private static readonly LayoutColumn Crc32Column;

        static RecordHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(LengthName, out LengthColumn);
            Contract.Invariant(found);
            found = layout.TryFind(Crc32Name, out Crc32Column);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, Record value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, Record value)
        {
            Result r;
            if (value.Length != default)
            {
                r = LayoutType.Int32.WriteFixed(ref row, ref scope, LengthColumn, value.Length);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Crc32 != default)
            {
                r = LayoutType.UInt32.WriteFixed(ref row, ref scope, Crc32Column, value.Crc32);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out Record value)
        {
            if (isRoot)
            {
                value = new Record();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new Record();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref Record value)
        {
            Result r;
            {
                r = LayoutType.Int32.ReadFixed(ref row, ref scope, LengthColumn, out int fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Length = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.UInt32.ReadFixed(ref row, ref scope, Crc32Column, out uint fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Crc32 = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            return Result.Success;
        }

        public sealed class RecordComparer : EqualityComparer<Record>
        {
            public static new readonly RecordComparer Default = new RecordComparer();

            public override bool Equals(Record x, Record y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Int32HybridRowSerializer).Comparer.Equals(x.Length, y.Length) && 
                    default(UInt32HybridRowSerializer).Comparer.Equals(x.Crc32, y.Crc32);
            }

            public override int GetHashCode(Record obj)
            {
                return HashCode.Combine(
                    default(Int32HybridRowSerializer).Comparer.GetHashCode(obj.Length),
                    default(UInt32HybridRowSerializer).Comparer.GetHashCode(obj.Crc32));
            }
        }
    }

    public readonly struct NamespaceHybridRowSerializer : IHybridRowSerializer<Namespace>
    {
        public const int SchemaId = 2147473651;
        public const int Size = 2;
        public IEqualityComparer<Namespace> Comparer => NamespaceComparer.Default;
        private static readonly Utf8String VersionName = Utf8String.TranscodeUtf16("version");
        private static readonly Utf8String NameName = Utf8String.TranscodeUtf16("name");
        private static readonly Utf8String CommentName = Utf8String.TranscodeUtf16("comment");
        private static readonly Utf8String SchemasName = Utf8String.TranscodeUtf16("schemas");
        private static readonly Utf8String EnumsName = Utf8String.TranscodeUtf16("enums");
        private static readonly Utf8String CppNamespaceName = Utf8String.TranscodeUtf16("cppNamespace");

        private static readonly LayoutColumn VersionColumn;
        private static readonly LayoutColumn NameColumn;
        private static readonly LayoutColumn CommentColumn;
        private static readonly LayoutColumn SchemasColumn;
        private static readonly LayoutColumn EnumsColumn;
        private static readonly LayoutColumn CppNamespaceColumn;

        private static readonly StringToken CommentToken;
        private static readonly StringToken SchemasToken;
        private static readonly StringToken EnumsToken;
        private static readonly StringToken CppNamespaceToken;

        static NamespaceHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(VersionName, out VersionColumn);
            Contract.Invariant(found);
            found = layout.TryFind(NameName, out NameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CommentName, out CommentColumn);
            Contract.Invariant(found);
            found = layout.TryFind(SchemasName, out SchemasColumn);
            Contract.Invariant(found);
            found = layout.TryFind(EnumsName, out EnumsColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CppNamespaceName, out CppNamespaceColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(CommentColumn.Path, out CommentToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(SchemasColumn.Path, out SchemasToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(EnumsColumn.Path, out EnumsToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(CppNamespaceColumn.Path, out CppNamespaceToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, Namespace value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, Namespace value)
        {
            Result r;
            if (value.Version != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, VersionColumn, (byte)value.Version);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Name != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, NameColumn, value.Name);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Comment != default)
            {
                scope.Find(ref row, CommentColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Comment);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.Schemas != null) && (value.Schemas.Count > 0))
            {
                scope.Find(ref row, SchemasColumn.Path);
                r = default(TypedArrayHybridRowSerializer<Schema, SchemaHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    SchemasColumn.TypeArgs,
                    value.Schemas);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.Enums != null) && (value.Enums.Count > 0))
            {
                scope.Find(ref row, EnumsColumn.Path);
                r = default(TypedArrayHybridRowSerializer<EnumSchema, EnumSchemaHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    EnumsColumn.TypeArgs,
                    value.Enums);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.CppNamespace != default)
            {
                scope.Find(ref row, CppNamespaceColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.CppNamespace);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out Namespace value)
        {
            if (isRoot)
            {
                value = new Namespace();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new Namespace();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref Namespace value)
        {
            Result r;
            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, VersionColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Version = (SchemaLanguageVersion)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, NameColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Name = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == CommentToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Comment = fieldValue;
                    continue;
                }

                if (scope.Token == SchemasToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<Schema, SchemaHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<Schema> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Schemas = fieldValue;
                    continue;
                }

                if (scope.Token == EnumsToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<EnumSchema, EnumSchemaHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<EnumSchema> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Enums = fieldValue;
                    continue;
                }

                if (scope.Token == CppNamespaceToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.CppNamespace = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class NamespaceComparer : EqualityComparer<Namespace>
        {
            public static new readonly NamespaceComparer Default = new NamespaceComparer();

            public override bool Equals(Namespace x, Namespace y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Version, (byte)y.Version) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Name, y.Name) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Comment, y.Comment) && 
                    default(TypedArrayHybridRowSerializer<Schema, SchemaHybridRowSerializer>).Comparer.Equals(x.Schemas, y.Schemas) && 
                    default(TypedArrayHybridRowSerializer<EnumSchema, EnumSchemaHybridRowSerializer>).Comparer.Equals(x.Enums, y.Enums) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.CppNamespace, y.CppNamespace);
            }

            public override int GetHashCode(Namespace obj)
            {
                return HashCode.Combine(
                    default(UInt8HybridRowSerializer).Comparer.GetHashCode((byte)obj.Version),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Name),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Comment),
                    default(TypedArrayHybridRowSerializer<Schema, SchemaHybridRowSerializer>).Comparer.GetHashCode(obj.Schemas),
                    default(TypedArrayHybridRowSerializer<EnumSchema, EnumSchemaHybridRowSerializer>).Comparer.GetHashCode(obj.Enums),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.CppNamespace));
            }
        }
    }

    public readonly struct SchemaHybridRowSerializer : IHybridRowSerializer<Schema>
    {
        public const int SchemaId = 2147473652;
        public const int Size = 7;
        public IEqualityComparer<Schema> Comparer => SchemaComparer.Default;
        private static readonly Utf8String VersionName = Utf8String.TranscodeUtf16("version");
        private static readonly Utf8String TypeName = Utf8String.TranscodeUtf16("type");
        private static readonly Utf8String SchemaIdName = Utf8String.TranscodeUtf16("id");
        private static readonly Utf8String NameName = Utf8String.TranscodeUtf16("name");
        private static readonly Utf8String CommentName = Utf8String.TranscodeUtf16("comment");
        private static readonly Utf8String OptionsName = Utf8String.TranscodeUtf16("options");
        private static readonly Utf8String PartitionKeysName = Utf8String.TranscodeUtf16("partitionKeys");
        private static readonly Utf8String PrimaryKeysName = Utf8String.TranscodeUtf16("primaryKeys");
        private static readonly Utf8String StaticKeysName = Utf8String.TranscodeUtf16("staticKeys");
        private static readonly Utf8String PropertiesName = Utf8String.TranscodeUtf16("properties");
        private static readonly Utf8String BaseNameName = Utf8String.TranscodeUtf16("baseName");
        private static readonly Utf8String BaseSchemaIdName = Utf8String.TranscodeUtf16("baseId");

        private static readonly LayoutColumn VersionColumn;
        private static readonly LayoutColumn TypeColumn;
        private static readonly LayoutColumn SchemaIdColumn;
        private static readonly LayoutColumn NameColumn;
        private static readonly LayoutColumn CommentColumn;
        private static readonly LayoutColumn OptionsColumn;
        private static readonly LayoutColumn PartitionKeysColumn;
        private static readonly LayoutColumn PrimaryKeysColumn;
        private static readonly LayoutColumn StaticKeysColumn;
        private static readonly LayoutColumn PropertiesColumn;
        private static readonly LayoutColumn BaseNameColumn;
        private static readonly LayoutColumn BaseSchemaIdColumn;

        private static readonly StringToken CommentToken;
        private static readonly StringToken OptionsToken;
        private static readonly StringToken PartitionKeysToken;
        private static readonly StringToken PrimaryKeysToken;
        private static readonly StringToken StaticKeysToken;
        private static readonly StringToken PropertiesToken;
        private static readonly StringToken BaseNameToken;
        private static readonly StringToken BaseSchemaIdToken;

        static SchemaHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(VersionName, out VersionColumn);
            Contract.Invariant(found);
            found = layout.TryFind(TypeName, out TypeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(SchemaIdName, out SchemaIdColumn);
            Contract.Invariant(found);
            found = layout.TryFind(NameName, out NameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CommentName, out CommentColumn);
            Contract.Invariant(found);
            found = layout.TryFind(OptionsName, out OptionsColumn);
            Contract.Invariant(found);
            found = layout.TryFind(PartitionKeysName, out PartitionKeysColumn);
            Contract.Invariant(found);
            found = layout.TryFind(PrimaryKeysName, out PrimaryKeysColumn);
            Contract.Invariant(found);
            found = layout.TryFind(StaticKeysName, out StaticKeysColumn);
            Contract.Invariant(found);
            found = layout.TryFind(PropertiesName, out PropertiesColumn);
            Contract.Invariant(found);
            found = layout.TryFind(BaseNameName, out BaseNameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(BaseSchemaIdName, out BaseSchemaIdColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(CommentColumn.Path, out CommentToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(OptionsColumn.Path, out OptionsToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(PartitionKeysColumn.Path, out PartitionKeysToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(PrimaryKeysColumn.Path, out PrimaryKeysToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(StaticKeysColumn.Path, out StaticKeysToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(PropertiesColumn.Path, out PropertiesToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(BaseNameColumn.Path, out BaseNameToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(BaseSchemaIdColumn.Path, out BaseSchemaIdToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, Schema value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, Schema value)
        {
            Result r;
            if (value.Version != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, VersionColumn, (byte)value.Version);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Type != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, TypeColumn, (byte)value.Type);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.SchemaId != default)
            {
                r = LayoutType.Int32.WriteFixed(ref row, ref scope, SchemaIdColumn, (int)value.SchemaId);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Name != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, NameColumn, value.Name);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Comment != default)
            {
                scope.Find(ref row, CommentColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Comment);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Options != default)
            {
                scope.Find(ref row, OptionsColumn.Path);
                r = default(SchemaOptionsHybridRowSerializer)
                    .Write(ref row, ref scope, false, OptionsColumn.TypeArgs, value.Options);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.PartitionKeys != null) && (value.PartitionKeys.Count > 0))
            {
                scope.Find(ref row, PartitionKeysColumn.Path);
                r = default(TypedArrayHybridRowSerializer<PartitionKey, PartitionKeyHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    PartitionKeysColumn.TypeArgs,
                    value.PartitionKeys);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.PrimaryKeys != null) && (value.PrimaryKeys.Count > 0))
            {
                scope.Find(ref row, PrimaryKeysColumn.Path);
                r = default(TypedArrayHybridRowSerializer<PrimarySortKey, PrimarySortKeyHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    PrimaryKeysColumn.TypeArgs,
                    value.PrimaryKeys);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.StaticKeys != null) && (value.StaticKeys.Count > 0))
            {
                scope.Find(ref row, StaticKeysColumn.Path);
                r = default(TypedArrayHybridRowSerializer<StaticKey, StaticKeyHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    StaticKeysColumn.TypeArgs,
                    value.StaticKeys);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.Properties != null) && (value.Properties.Count > 0))
            {
                scope.Find(ref row, PropertiesColumn.Path);
                r = default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    PropertiesColumn.TypeArgs,
                    value.Properties);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.BaseName != default)
            {
                scope.Find(ref row, BaseNameColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.BaseName);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.BaseSchemaId != default)
            {
                scope.Find(ref row, BaseSchemaIdColumn.Path);
                r = LayoutType.Int32.WriteSparse(ref row, ref scope, (int)value.BaseSchemaId);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out Schema value)
        {
            if (isRoot)
            {
                value = new Schema();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new Schema();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref Schema value)
        {
            Result r;
            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, VersionColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Version = (SchemaLanguageVersion)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, TypeColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Type = (TypeKind)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Int32.ReadFixed(ref row, ref scope, SchemaIdColumn, out int fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.SchemaId = (SchemaId)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, NameColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Name = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == CommentToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Comment = fieldValue;
                    continue;
                }

                if (scope.Token == OptionsToken.Id)
                {
                    r = default(SchemaOptionsHybridRowSerializer)
                        .Read(ref row, ref scope, false, out SchemaOptions fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Options = fieldValue;
                    continue;
                }

                if (scope.Token == PartitionKeysToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<PartitionKey, PartitionKeyHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<PartitionKey> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.PartitionKeys = fieldValue;
                    continue;
                }

                if (scope.Token == PrimaryKeysToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<PrimarySortKey, PrimarySortKeyHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<PrimarySortKey> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.PrimaryKeys = fieldValue;
                    continue;
                }

                if (scope.Token == StaticKeysToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<StaticKey, StaticKeyHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<StaticKey> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.StaticKeys = fieldValue;
                    continue;
                }

                if (scope.Token == PropertiesToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<Property> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Properties = fieldValue;
                    continue;
                }

                if (scope.Token == BaseNameToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.BaseName = fieldValue;
                    continue;
                }

                if (scope.Token == BaseSchemaIdToken.Id)
                {
                    r = LayoutType.Int32.ReadSparse(ref row, ref scope, out int fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.BaseSchemaId = (SchemaId)fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class SchemaComparer : EqualityComparer<Schema>
        {
            public static new readonly SchemaComparer Default = new SchemaComparer();

            public override bool Equals(Schema x, Schema y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Version, (byte)y.Version) && 
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Type, (byte)y.Type) && 
                    default(Int32HybridRowSerializer).Comparer.Equals((int)x.SchemaId, (int)y.SchemaId) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Name, y.Name) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Comment, y.Comment) && 
                    default(SchemaOptionsHybridRowSerializer).Comparer.Equals(x.Options, y.Options) && 
                    default(TypedArrayHybridRowSerializer<PartitionKey, PartitionKeyHybridRowSerializer>).Comparer.Equals(x.PartitionKeys, y.PartitionKeys) && 
                    default(TypedArrayHybridRowSerializer<PrimarySortKey, PrimarySortKeyHybridRowSerializer>).Comparer.Equals(x.PrimaryKeys, y.PrimaryKeys) && 
                    default(TypedArrayHybridRowSerializer<StaticKey, StaticKeyHybridRowSerializer>).Comparer.Equals(x.StaticKeys, y.StaticKeys) && 
                    default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>).Comparer.Equals(x.Properties, y.Properties) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.BaseName, y.BaseName) && 
                    default(Int32HybridRowSerializer).Comparer.Equals((int)x.BaseSchemaId, (int)y.BaseSchemaId);
            }

            public override int GetHashCode(Schema obj)
            {
                HashCode hash = default;
                hash.Add((byte)obj.Version, default(UInt8HybridRowSerializer).Comparer);
                hash.Add((byte)obj.Type, default(UInt8HybridRowSerializer).Comparer);
                hash.Add((int)obj.SchemaId, default(Int32HybridRowSerializer).Comparer);
                hash.Add(obj.Name, default(Utf8HybridRowSerializer).Comparer);
                hash.Add(obj.Comment, default(Utf8HybridRowSerializer).Comparer);
                hash.Add(obj.Options, default(SchemaOptionsHybridRowSerializer).Comparer);
                hash.Add(obj.PartitionKeys, default(TypedArrayHybridRowSerializer<PartitionKey, PartitionKeyHybridRowSerializer>).Comparer);
                hash.Add(obj.PrimaryKeys, default(TypedArrayHybridRowSerializer<PrimarySortKey, PrimarySortKeyHybridRowSerializer>).Comparer);
                hash.Add(obj.StaticKeys, default(TypedArrayHybridRowSerializer<StaticKey, StaticKeyHybridRowSerializer>).Comparer);
                hash.Add(obj.Properties, default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>).Comparer);
                hash.Add(obj.BaseName, default(Utf8HybridRowSerializer).Comparer);
                hash.Add((int)obj.BaseSchemaId, default(Int32HybridRowSerializer).Comparer);
                return hash.ToHashCode();
            }
        }
    }

    /// <summary>
    /// Describes the set of options that apply to the entire schema and the way it is validated.
    /// </summary>
    public readonly struct SchemaOptionsHybridRowSerializer : IHybridRowSerializer<SchemaOptions>
    {
        public const int SchemaId = 2147473653;
        public const int Size = 0;
        public IEqualityComparer<SchemaOptions> Comparer => SchemaOptionsComparer.Default;
        private static readonly Utf8String DisallowUnschematizedName = Utf8String.TranscodeUtf16("disallowUnschematized");
        private static readonly Utf8String EnablePropertyLevelTimestampName = Utf8String.TranscodeUtf16("enablePropertyLevelTimestamp");
        private static readonly Utf8String DisableSystemPrefixName = Utf8String.TranscodeUtf16("disableSystemPrefix");
        private static readonly Utf8String AbstractName = Utf8String.TranscodeUtf16("abstract");

        private static readonly LayoutColumn DisallowUnschematizedColumn;
        private static readonly LayoutColumn EnablePropertyLevelTimestampColumn;
        private static readonly LayoutColumn DisableSystemPrefixColumn;
        private static readonly LayoutColumn AbstractColumn;

        private static readonly StringToken DisallowUnschematizedToken;
        private static readonly StringToken EnablePropertyLevelTimestampToken;
        private static readonly StringToken DisableSystemPrefixToken;
        private static readonly StringToken AbstractToken;

        static SchemaOptionsHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(DisallowUnschematizedName, out DisallowUnschematizedColumn);
            Contract.Invariant(found);
            found = layout.TryFind(EnablePropertyLevelTimestampName, out EnablePropertyLevelTimestampColumn);
            Contract.Invariant(found);
            found = layout.TryFind(DisableSystemPrefixName, out DisableSystemPrefixColumn);
            Contract.Invariant(found);
            found = layout.TryFind(AbstractName, out AbstractColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(DisallowUnschematizedColumn.Path, out DisallowUnschematizedToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(EnablePropertyLevelTimestampColumn.Path, out EnablePropertyLevelTimestampToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(DisableSystemPrefixColumn.Path, out DisableSystemPrefixToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(AbstractColumn.Path, out AbstractToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, SchemaOptions value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, SchemaOptions value)
        {
            Result r;
            if (value.DisallowUnschematized != default)
            {
                scope.Find(ref row, DisallowUnschematizedColumn.Path);
                r = LayoutType.Boolean.WriteSparse(ref row, ref scope, value.DisallowUnschematized);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.EnablePropertyLevelTimestamp != default)
            {
                scope.Find(ref row, EnablePropertyLevelTimestampColumn.Path);
                r = LayoutType.Boolean.WriteSparse(ref row, ref scope, value.EnablePropertyLevelTimestamp);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.DisableSystemPrefix != default)
            {
                scope.Find(ref row, DisableSystemPrefixColumn.Path);
                r = LayoutType.Boolean.WriteSparse(ref row, ref scope, value.DisableSystemPrefix);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Abstract != default)
            {
                scope.Find(ref row, AbstractColumn.Path);
                r = LayoutType.Boolean.WriteSparse(ref row, ref scope, value.Abstract);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out SchemaOptions value)
        {
            if (isRoot)
            {
                value = new SchemaOptions();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new SchemaOptions();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref SchemaOptions value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == DisallowUnschematizedToken.Id)
                {
                    r = LayoutType.Boolean.ReadSparse(ref row, ref scope, out bool fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.DisallowUnschematized = fieldValue;
                    continue;
                }

                if (scope.Token == EnablePropertyLevelTimestampToken.Id)
                {
                    r = LayoutType.Boolean.ReadSparse(ref row, ref scope, out bool fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.EnablePropertyLevelTimestamp = fieldValue;
                    continue;
                }

                if (scope.Token == DisableSystemPrefixToken.Id)
                {
                    r = LayoutType.Boolean.ReadSparse(ref row, ref scope, out bool fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.DisableSystemPrefix = fieldValue;
                    continue;
                }

                if (scope.Token == AbstractToken.Id)
                {
                    r = LayoutType.Boolean.ReadSparse(ref row, ref scope, out bool fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Abstract = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class SchemaOptionsComparer : EqualityComparer<SchemaOptions>
        {
            public static new readonly SchemaOptionsComparer Default = new SchemaOptionsComparer();

            public override bool Equals(SchemaOptions x, SchemaOptions y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.DisallowUnschematized, y.DisallowUnschematized) && 
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.EnablePropertyLevelTimestamp, y.EnablePropertyLevelTimestamp) && 
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.DisableSystemPrefix, y.DisableSystemPrefix) && 
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.Abstract, y.Abstract);
            }

            public override int GetHashCode(SchemaOptions obj)
            {
                return HashCode.Combine(
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.DisallowUnschematized),
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.EnablePropertyLevelTimestamp),
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.DisableSystemPrefix),
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.Abstract));
            }
        }
    }

    public readonly struct PartitionKeyHybridRowSerializer : IHybridRowSerializer<PartitionKey>
    {
        public const int SchemaId = 2147473654;
        public const int Size = 1;
        public IEqualityComparer<PartitionKey> Comparer => PartitionKeyComparer.Default;
        private static readonly Utf8String PathName = Utf8String.TranscodeUtf16("path");

        private static readonly LayoutColumn PathColumn;

        static PartitionKeyHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(PathName, out PathColumn);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, PartitionKey value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, PartitionKey value)
        {
            Result r;
            if (value.Path != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, PathColumn, value.Path);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out PartitionKey value)
        {
            if (isRoot)
            {
                value = new PartitionKey();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new PartitionKey();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref PartitionKey value)
        {
            Result r;
            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, PathColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Path = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            return Result.Success;
        }

        public sealed class PartitionKeyComparer : EqualityComparer<PartitionKey>
        {
            public static new readonly PartitionKeyComparer Default = new PartitionKeyComparer();

            public override bool Equals(PartitionKey x, PartitionKey y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return default(Utf8HybridRowSerializer).Comparer.Equals(x.Path, y.Path);
            }

            public override int GetHashCode(PartitionKey obj)
            {
                return default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Path);
            }
        }
    }

    public readonly struct PrimarySortKeyHybridRowSerializer : IHybridRowSerializer<PrimarySortKey>
    {
        public const int SchemaId = 2147473655;
        public const int Size = 2;
        public IEqualityComparer<PrimarySortKey> Comparer => PrimarySortKeyComparer.Default;
        private static readonly Utf8String PathName = Utf8String.TranscodeUtf16("path");
        private static readonly Utf8String DirectionName = Utf8String.TranscodeUtf16("direction");

        private static readonly LayoutColumn PathColumn;
        private static readonly LayoutColumn DirectionColumn;

        static PrimarySortKeyHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(PathName, out PathColumn);
            Contract.Invariant(found);
            found = layout.TryFind(DirectionName, out DirectionColumn);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, PrimarySortKey value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, PrimarySortKey value)
        {
            Result r;
            if (value.Direction != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, DirectionColumn, (byte)value.Direction);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Path != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, PathColumn, value.Path);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out PrimarySortKey value)
        {
            if (isRoot)
            {
                value = new PrimarySortKey();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new PrimarySortKey();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref PrimarySortKey value)
        {
            Result r;
            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, DirectionColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Direction = (SortDirection)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, PathColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Path = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            return Result.Success;
        }

        public sealed class PrimarySortKeyComparer : EqualityComparer<PrimarySortKey>
        {
            public static new readonly PrimarySortKeyComparer Default = new PrimarySortKeyComparer();

            public override bool Equals(PrimarySortKey x, PrimarySortKey y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Path, y.Path) && 
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Direction, (byte)y.Direction);
            }

            public override int GetHashCode(PrimarySortKey obj)
            {
                return HashCode.Combine(
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Path),
                    default(UInt8HybridRowSerializer).Comparer.GetHashCode((byte)obj.Direction));
            }
        }
    }

    public readonly struct StaticKeyHybridRowSerializer : IHybridRowSerializer<StaticKey>
    {
        public const int SchemaId = 2147473656;
        public const int Size = 1;
        public IEqualityComparer<StaticKey> Comparer => StaticKeyComparer.Default;
        private static readonly Utf8String PathName = Utf8String.TranscodeUtf16("path");

        private static readonly LayoutColumn PathColumn;

        static StaticKeyHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(PathName, out PathColumn);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, StaticKey value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, StaticKey value)
        {
            Result r;
            if (value.Path != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, PathColumn, value.Path);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out StaticKey value)
        {
            if (isRoot)
            {
                value = new StaticKey();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new StaticKey();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref StaticKey value)
        {
            Result r;
            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, PathColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Path = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            return Result.Success;
        }

        public sealed class StaticKeyComparer : EqualityComparer<StaticKey>
        {
            public static new readonly StaticKeyComparer Default = new StaticKeyComparer();

            public override bool Equals(StaticKey x, StaticKey y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return default(Utf8HybridRowSerializer).Comparer.Equals(x.Path, y.Path);
            }

            public override int GetHashCode(StaticKey obj)
            {
                return default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Path);
            }
        }
    }

    public readonly struct PropertyHybridRowSerializer : IHybridRowSerializer<Property>
    {
        public const int SchemaId = 2147473657;
        public const int Size = 1;
        public IEqualityComparer<Property> Comparer => PropertyComparer.Default;
        private static readonly Utf8String PathName = Utf8String.TranscodeUtf16("path");
        private static readonly Utf8String CommentName = Utf8String.TranscodeUtf16("comment");
        private static readonly Utf8String PropertyTypeName = Utf8String.TranscodeUtf16("type");
        private static readonly Utf8String ApiNameName = Utf8String.TranscodeUtf16("apiname");
        private static readonly Utf8String AllowEmptyName = Utf8String.TranscodeUtf16("allowEmpty");

        private static readonly LayoutColumn PathColumn;
        private static readonly LayoutColumn CommentColumn;
        private static readonly LayoutColumn PropertyTypeColumn;
        private static readonly LayoutColumn ApiNameColumn;
        private static readonly LayoutColumn AllowEmptyColumn;

        private static readonly StringToken CommentToken;
        private static readonly StringToken PropertyTypeToken;
        private static readonly StringToken ApiNameToken;
        private static readonly StringToken AllowEmptyToken;

        static PropertyHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(PathName, out PathColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CommentName, out CommentColumn);
            Contract.Invariant(found);
            found = layout.TryFind(PropertyTypeName, out PropertyTypeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(ApiNameName, out ApiNameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(AllowEmptyName, out AllowEmptyColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(CommentColumn.Path, out CommentToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(PropertyTypeColumn.Path, out PropertyTypeToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(ApiNameColumn.Path, out ApiNameToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(AllowEmptyColumn.Path, out AllowEmptyToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, Property value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, Property value)
        {
            Result r;
            if (value.Path != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, PathColumn, value.Path);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Comment != default)
            {
                scope.Find(ref row, CommentColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Comment);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.PropertyType != default)
            {
                scope.Find(ref row, PropertyTypeColumn.Path);
                r = default(PropertyTypeHybridRowSerializer)
                    .Write(ref row, ref scope, false, PropertyTypeColumn.TypeArgs, value.PropertyType);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.ApiName != default)
            {
                scope.Find(ref row, ApiNameColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.ApiName);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.AllowEmpty != default)
            {
                scope.Find(ref row, AllowEmptyColumn.Path);
                r = LayoutType.UInt8.WriteSparse(ref row, ref scope, (byte)value.AllowEmpty);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out Property value)
        {
            if (isRoot)
            {
                value = new Property();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new Property();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref Property value)
        {
            Result r;
            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, PathColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Path = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == CommentToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Comment = fieldValue;
                    continue;
                }

                if (scope.Token == PropertyTypeToken.Id)
                {
                    r = default(PropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out PropertyType fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.PropertyType = fieldValue;
                    continue;
                }

                if (scope.Token == ApiNameToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.ApiName = fieldValue;
                    continue;
                }

                if (scope.Token == AllowEmptyToken.Id)
                {
                    r = LayoutType.UInt8.ReadSparse(ref row, ref scope, out byte fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.AllowEmpty = (AllowEmptyKind)fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class PropertyComparer : EqualityComparer<Property>
        {
            public static new readonly PropertyComparer Default = new PropertyComparer();

            public override bool Equals(Property x, Property y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Path, y.Path) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Comment, y.Comment) && 
                    default(PropertyTypeHybridRowSerializer).Comparer.Equals(x.PropertyType, y.PropertyType) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.ApiName, y.ApiName) && 
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.AllowEmpty, (byte)y.AllowEmpty);
            }

            public override int GetHashCode(Property obj)
            {
                return HashCode.Combine(
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Path),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Comment),
                    default(PropertyTypeHybridRowSerializer).Comparer.GetHashCode(obj.PropertyType),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.ApiName),
                    default(UInt8HybridRowSerializer).Comparer.GetHashCode((byte)obj.AllowEmpty));
            }
        }
    }

    public readonly struct PropertyTypeHybridRowSerializer : IHybridRowSerializer<PropertyType>
    {
        public const int SchemaId = 2147473658;
        public const int Size = 2;
        public IEqualityComparer<PropertyType> Comparer => PropertyTypeComparer.Default;
        private static readonly Utf8String ApiTypeName = Utf8String.TranscodeUtf16("apitype");
        private static readonly Utf8String TypeName = Utf8String.TranscodeUtf16("type");
        private static readonly Utf8String NullableName = Utf8String.TranscodeUtf16("nullable");

        private static readonly LayoutColumn ApiTypeColumn;
        private static readonly LayoutColumn TypeColumn;
        private static readonly LayoutColumn NullableColumn;

        static PropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(ApiTypeName, out ApiTypeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(TypeName, out TypeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(NullableName, out NullableColumn);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, PropertyType value)
        {
            switch (value)
            {
                case PrimitivePropertyType p:
                    return default(PrimitivePropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case ScopePropertyType p:
                    return default(ScopePropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                default:
                    break;
            }

            Contract.Fail("Type is abstract.");
            return Result.Failure;
        }

        public static Result WriteBase(ref RowBuffer row, ref RowCursor scope, PropertyType value)
        {
            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, PropertyType value)
        {
            Result r;
            if (value.Type != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, TypeColumn, (byte)value.Type);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Nullable != default)
            {
                r = LayoutType.Boolean.WriteFixed(ref row, ref scope, NullableColumn, value.Nullable);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.ApiType != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, ApiTypeColumn, value.ApiType);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out PropertyType value)
        {
            if (!(scope.TypeArg.Type is LayoutUDT))
            {
                value = default;
                return Result.TypeMismatch;
            }

            switch (scope.TypeArg.TypeArgs.SchemaId.Id)
            {
                case PrimitivePropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(PrimitivePropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out PrimitivePropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case ArrayPropertyTypeHybridRowSerializer.SchemaId:
                case ObjectPropertyTypeHybridRowSerializer.SchemaId:
                case UdtPropertyTypeHybridRowSerializer.SchemaId:
                case SetPropertyTypeHybridRowSerializer.SchemaId:
                case MapPropertyTypeHybridRowSerializer.SchemaId:
                case TuplePropertyTypeHybridRowSerializer.SchemaId:
                case TaggedPropertyTypeHybridRowSerializer.SchemaId:
                case ScopePropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(ScopePropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out ScopePropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                default:
                    break;
            }

            Contract.Fail("Type is abstract.");
            value = default;
            return Result.Failure;
        }

        public static Result ReadBase(ref RowBuffer row, ref RowCursor scope, ref PropertyType value)
        {
            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref PropertyType value)
        {
            Result r;
            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, TypeColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Type = (TypeKind)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Boolean.ReadFixed(ref row, ref scope, NullableColumn, out bool fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Nullable = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, ApiTypeColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.ApiType = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            return Result.Success;
        }

        public sealed class PropertyTypeComparer : EqualityComparer<PropertyType>
        {
            public static new readonly PropertyTypeComparer Default = new PropertyTypeComparer();

            public override bool Equals(PropertyType x, PropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }
                switch (x)
                {
                    case PrimitivePropertyType p:
                        return default(PrimitivePropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (PrimitivePropertyType)y);
                    case ScopePropertyType p:
                        return default(ScopePropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (ScopePropertyType)y);
                    default:
                        break;
                }
                Contract.Fail("Type is abstract.");
                return false;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal static bool EqualsBase(PropertyType x, PropertyType y)
            {

                return
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.ApiType, y.ApiType) && 
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Type, (byte)y.Type) && 
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.Nullable, y.Nullable);
            }

            public override int GetHashCode(PropertyType obj)
            {
                switch (obj)
                {
                    case PrimitivePropertyType p:
                        return default(PrimitivePropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case ScopePropertyType p:
                        return default(ScopePropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    default:
                        break;
                }
                Contract.Fail("Type is abstract.");
                return 0;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal static int GetHashCodeBase(PropertyType obj)
            {
                return HashCode.Combine(
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.ApiType),
                    default(UInt8HybridRowSerializer).Comparer.GetHashCode((byte)obj.Type),
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.Nullable));
            }
        }
    }

    public readonly struct PrimitivePropertyTypeHybridRowSerializer : IHybridRowSerializer<PrimitivePropertyType>
    {
        public const int SchemaId = 2147473659;
        public const int Size = 5;
        public IEqualityComparer<PrimitivePropertyType> Comparer => PrimitivePropertyTypeComparer.Default;
        private static readonly Utf8String LengthName = Utf8String.TranscodeUtf16("length");
        private static readonly Utf8String StorageName = Utf8String.TranscodeUtf16("storage");
        private static readonly Utf8String EnumName = Utf8String.TranscodeUtf16("enum");
        private static readonly Utf8String RowBufferSizeName = Utf8String.TranscodeUtf16("rowBufferSize");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn LengthColumn;
        private static readonly LayoutColumn StorageColumn;
        private static readonly LayoutColumn EnumColumn;
        private static readonly LayoutColumn RowBufferSizeColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken EnumToken;
        private static readonly StringToken RowBufferSizeToken;
        private static readonly StringToken __BaseToken;

        static PrimitivePropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(LengthName, out LengthColumn);
            Contract.Invariant(found);
            found = layout.TryFind(StorageName, out StorageColumn);
            Contract.Invariant(found);
            found = layout.TryFind(EnumName, out EnumColumn);
            Contract.Invariant(found);
            found = layout.TryFind(RowBufferSizeName, out RowBufferSizeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(EnumColumn.Path, out EnumToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(RowBufferSizeColumn.Path, out RowBufferSizeToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, PrimitivePropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, PrimitivePropertyType value)
        {
            Result r;
            if (value.Length != default)
            {
                r = LayoutType.Int32.WriteFixed(ref row, ref scope, LengthColumn, value.Length);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Storage != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, StorageColumn, (byte)value.Storage);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (!string.IsNullOrEmpty(value.Enum))
            {
                scope.Find(ref row, EnumColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Enum);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.RowBufferSize != default)
            {
                scope.Find(ref row, RowBufferSizeColumn.Path);
                r = LayoutType.Boolean.WriteSparse(ref row, ref scope, value.RowBufferSize);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = PropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out PrimitivePropertyType value)
        {
            if (isRoot)
            {
                value = new PrimitivePropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new PrimitivePropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref PrimitivePropertyType value)
        {
            Result r;
            {
                r = LayoutType.Int32.ReadFixed(ref row, ref scope, LengthColumn, out int fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Length = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, StorageColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Storage = (StorageKind)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == EnumToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Enum = fieldValue;
                    continue;
                }

                if (scope.Token == RowBufferSizeToken.Id)
                {
                    r = LayoutType.Boolean.ReadSparse(ref row, ref scope, out bool fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.RowBufferSize = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    PropertyType baseValue = value;
                    r = PropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class PrimitivePropertyTypeComparer : EqualityComparer<PrimitivePropertyType>
        {
            public static new readonly PrimitivePropertyTypeComparer Default = new PrimitivePropertyTypeComparer();

            public override bool Equals(PrimitivePropertyType x, PrimitivePropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    PropertyTypeHybridRowSerializer.PropertyTypeComparer.EqualsBase(x, y) && 
                    default(Int32HybridRowSerializer).Comparer.Equals(x.Length, y.Length) && 
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Storage, (byte)y.Storage) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Enum, y.Enum) && 
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.RowBufferSize, y.RowBufferSize);
            }

            public override int GetHashCode(PrimitivePropertyType obj)
            {
                return HashCode.Combine(
                    PropertyTypeHybridRowSerializer.PropertyTypeComparer.GetHashCodeBase(obj),
                    default(Int32HybridRowSerializer).Comparer.GetHashCode(obj.Length),
                    default(UInt8HybridRowSerializer).Comparer.GetHashCode((byte)obj.Storage),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Enum),
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.RowBufferSize));
            }
        }
    }

    public readonly struct ScopePropertyTypeHybridRowSerializer : IHybridRowSerializer<ScopePropertyType>
    {
        public const int SchemaId = 2147473660;
        public const int Size = 1;
        public IEqualityComparer<ScopePropertyType> Comparer => ScopePropertyTypeComparer.Default;
        private static readonly Utf8String ImmutableName = Utf8String.TranscodeUtf16("immutable");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn ImmutableColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken __BaseToken;

        static ScopePropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(ImmutableName, out ImmutableColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, ScopePropertyType value)
        {
            switch (value)
            {
                case ArrayPropertyType p:
                    return default(ArrayPropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case ObjectPropertyType p:
                    return default(ObjectPropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case UdtPropertyType p:
                    return default(UdtPropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case SetPropertyType p:
                    return default(SetPropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case MapPropertyType p:
                    return default(MapPropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case TuplePropertyType p:
                    return default(TuplePropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                case TaggedPropertyType p:
                    return default(TaggedPropertyTypeHybridRowSerializer)
                        .Write(ref row, ref scope, isRoot, typeArgs, p);
                default:
                    break;
            }

            Contract.Fail("Type is abstract.");
            return Result.Failure;
        }

        public static Result WriteBase(ref RowBuffer row, ref RowCursor scope, ScopePropertyType value)
        {
            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, ScopePropertyType value)
        {
            Result r;
            if (value.Immutable != default)
            {
                r = LayoutType.Boolean.WriteFixed(ref row, ref scope, ImmutableColumn, value.Immutable);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = PropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out ScopePropertyType value)
        {
            if (!(scope.TypeArg.Type is LayoutUDT))
            {
                value = default;
                return Result.TypeMismatch;
            }

            switch (scope.TypeArg.TypeArgs.SchemaId.Id)
            {
                case ArrayPropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(ArrayPropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out ArrayPropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case ObjectPropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(ObjectPropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out ObjectPropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case UdtPropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(UdtPropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out UdtPropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case SetPropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(SetPropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out SetPropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case MapPropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(MapPropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out MapPropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case TuplePropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(TuplePropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out TuplePropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                case TaggedPropertyTypeHybridRowSerializer.SchemaId:
                {
                    Result r = default(TaggedPropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out TaggedPropertyType fieldValue);
                    value = fieldValue;
                    return r;
                }

                default:
                    break;
            }

            Contract.Fail("Type is abstract.");
            value = default;
            return Result.Failure;
        }

        public static Result ReadBase(ref RowBuffer row, ref RowCursor scope, ref ScopePropertyType value)
        {
            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref ScopePropertyType value)
        {
            Result r;
            {
                r = LayoutType.Boolean.ReadFixed(ref row, ref scope, ImmutableColumn, out bool fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Immutable = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == __BaseToken.Id)
                {
                    PropertyType baseValue = value;
                    r = PropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class ScopePropertyTypeComparer : EqualityComparer<ScopePropertyType>
        {
            public static new readonly ScopePropertyTypeComparer Default = new ScopePropertyTypeComparer();

            public override bool Equals(ScopePropertyType x, ScopePropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }
                switch (x)
                {
                    case ArrayPropertyType p:
                        return default(ArrayPropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (ArrayPropertyType)y);
                    case ObjectPropertyType p:
                        return default(ObjectPropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (ObjectPropertyType)y);
                    case UdtPropertyType p:
                        return default(UdtPropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (UdtPropertyType)y);
                    case SetPropertyType p:
                        return default(SetPropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (SetPropertyType)y);
                    case MapPropertyType p:
                        return default(MapPropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (MapPropertyType)y);
                    case TuplePropertyType p:
                        return default(TuplePropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (TuplePropertyType)y);
                    case TaggedPropertyType p:
                        return default(TaggedPropertyTypeHybridRowSerializer)
                            .Comparer.Equals(p, (TaggedPropertyType)y);
                    default:
                        break;
                }
                Contract.Fail("Type is abstract.");
                return false;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal static bool EqualsBase(ScopePropertyType x, ScopePropertyType y)
            {

                return
                    PropertyTypeHybridRowSerializer.PropertyTypeComparer.EqualsBase(x, y) && 
                    default(BooleanHybridRowSerializer).Comparer.Equals(x.Immutable, y.Immutable);
            }

            public override int GetHashCode(ScopePropertyType obj)
            {
                switch (obj)
                {
                    case ArrayPropertyType p:
                        return default(ArrayPropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case ObjectPropertyType p:
                        return default(ObjectPropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case UdtPropertyType p:
                        return default(UdtPropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case SetPropertyType p:
                        return default(SetPropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case MapPropertyType p:
                        return default(MapPropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case TuplePropertyType p:
                        return default(TuplePropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    case TaggedPropertyType p:
                        return default(TaggedPropertyTypeHybridRowSerializer)
                            .Comparer.GetHashCode(p);
                    default:
                        break;
                }
                Contract.Fail("Type is abstract.");
                return 0;
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal static int GetHashCodeBase(ScopePropertyType obj)
            {
                return HashCode.Combine(
                    PropertyTypeHybridRowSerializer.PropertyTypeComparer.GetHashCodeBase(obj),
                    default(BooleanHybridRowSerializer).Comparer.GetHashCode(obj.Immutable));
            }
        }
    }

    public readonly struct ArrayPropertyTypeHybridRowSerializer : IHybridRowSerializer<ArrayPropertyType>
    {
        public const int SchemaId = 2147473661;
        public const int Size = 0;
        public IEqualityComparer<ArrayPropertyType> Comparer => ArrayPropertyTypeComparer.Default;
        private static readonly Utf8String ItemsName = Utf8String.TranscodeUtf16("items");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn ItemsColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken ItemsToken;
        private static readonly StringToken __BaseToken;

        static ArrayPropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(ItemsName, out ItemsColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(ItemsColumn.Path, out ItemsToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, ArrayPropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, ArrayPropertyType value)
        {
            Result r;
            if (value.Items != default)
            {
                scope.Find(ref row, ItemsColumn.Path);
                r = default(PropertyTypeHybridRowSerializer)
                    .Write(ref row, ref scope, false, ItemsColumn.TypeArgs, value.Items);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out ArrayPropertyType value)
        {
            if (isRoot)
            {
                value = new ArrayPropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new ArrayPropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref ArrayPropertyType value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == ItemsToken.Id)
                {
                    r = default(PropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out PropertyType fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Items = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class ArrayPropertyTypeComparer : EqualityComparer<ArrayPropertyType>
        {
            public static new readonly ArrayPropertyTypeComparer Default = new ArrayPropertyTypeComparer();

            public override bool Equals(ArrayPropertyType x, ArrayPropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(PropertyTypeHybridRowSerializer).Comparer.Equals(x.Items, y.Items);
            }

            public override int GetHashCode(ArrayPropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(PropertyTypeHybridRowSerializer).Comparer.GetHashCode(obj.Items));
            }
        }
    }

    public readonly struct ObjectPropertyTypeHybridRowSerializer : IHybridRowSerializer<ObjectPropertyType>
    {
        public const int SchemaId = 2147473662;
        public const int Size = 0;
        public IEqualityComparer<ObjectPropertyType> Comparer => ObjectPropertyTypeComparer.Default;
        private static readonly Utf8String PropertiesName = Utf8String.TranscodeUtf16("properties");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn PropertiesColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken PropertiesToken;
        private static readonly StringToken __BaseToken;

        static ObjectPropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(PropertiesName, out PropertiesColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(PropertiesColumn.Path, out PropertiesToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, ObjectPropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, ObjectPropertyType value)
        {
            Result r;
            if ((value.Properties != null) && (value.Properties.Count > 0))
            {
                scope.Find(ref row, PropertiesColumn.Path);
                r = default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    PropertiesColumn.TypeArgs,
                    value.Properties);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out ObjectPropertyType value)
        {
            if (isRoot)
            {
                value = new ObjectPropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new ObjectPropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref ObjectPropertyType value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == PropertiesToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<Property> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Properties = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class ObjectPropertyTypeComparer : EqualityComparer<ObjectPropertyType>
        {
            public static new readonly ObjectPropertyTypeComparer Default = new ObjectPropertyTypeComparer();

            public override bool Equals(ObjectPropertyType x, ObjectPropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>).Comparer.Equals(x.Properties, y.Properties);
            }

            public override int GetHashCode(ObjectPropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>).Comparer.GetHashCode(obj.Properties));
            }
        }
    }

    public readonly struct UdtPropertyTypeHybridRowSerializer : IHybridRowSerializer<UdtPropertyType>
    {
        public const int SchemaId = 2147473663;
        public const int Size = 5;
        public IEqualityComparer<UdtPropertyType> Comparer => UdtPropertyTypeComparer.Default;
        private static readonly Utf8String NameName = Utf8String.TranscodeUtf16("name");
        private static readonly Utf8String SchemaIdName = Utf8String.TranscodeUtf16("id");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn NameColumn;
        private static readonly LayoutColumn SchemaIdColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken __BaseToken;

        static UdtPropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(NameName, out NameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(SchemaIdName, out SchemaIdColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, UdtPropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, UdtPropertyType value)
        {
            Result r;
            if (value.SchemaId != default)
            {
                r = LayoutType.Int32.WriteFixed(ref row, ref scope, SchemaIdColumn, (int)value.SchemaId);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Name != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, NameColumn, value.Name);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out UdtPropertyType value)
        {
            if (isRoot)
            {
                value = new UdtPropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new UdtPropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref UdtPropertyType value)
        {
            Result r;
            {
                r = LayoutType.Int32.ReadFixed(ref row, ref scope, SchemaIdColumn, out int fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.SchemaId = (SchemaId)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, NameColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Name = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class UdtPropertyTypeComparer : EqualityComparer<UdtPropertyType>
        {
            public static new readonly UdtPropertyTypeComparer Default = new UdtPropertyTypeComparer();

            public override bool Equals(UdtPropertyType x, UdtPropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Name, y.Name) && 
                    default(Int32HybridRowSerializer).Comparer.Equals((int)x.SchemaId, (int)y.SchemaId);
            }

            public override int GetHashCode(UdtPropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Name),
                    default(Int32HybridRowSerializer).Comparer.GetHashCode((int)obj.SchemaId));
            }
        }
    }

    public readonly struct SetPropertyTypeHybridRowSerializer : IHybridRowSerializer<SetPropertyType>
    {
        public const int SchemaId = 2147473664;
        public const int Size = 0;
        public IEqualityComparer<SetPropertyType> Comparer => SetPropertyTypeComparer.Default;
        private static readonly Utf8String ItemsName = Utf8String.TranscodeUtf16("items");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn ItemsColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken ItemsToken;
        private static readonly StringToken __BaseToken;

        static SetPropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(ItemsName, out ItemsColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(ItemsColumn.Path, out ItemsToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, SetPropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, SetPropertyType value)
        {
            Result r;
            if (value.Items != default)
            {
                scope.Find(ref row, ItemsColumn.Path);
                r = default(PropertyTypeHybridRowSerializer)
                    .Write(ref row, ref scope, false, ItemsColumn.TypeArgs, value.Items);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out SetPropertyType value)
        {
            if (isRoot)
            {
                value = new SetPropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new SetPropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref SetPropertyType value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == ItemsToken.Id)
                {
                    r = default(PropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out PropertyType fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Items = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class SetPropertyTypeComparer : EqualityComparer<SetPropertyType>
        {
            public static new readonly SetPropertyTypeComparer Default = new SetPropertyTypeComparer();

            public override bool Equals(SetPropertyType x, SetPropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(PropertyTypeHybridRowSerializer).Comparer.Equals(x.Items, y.Items);
            }

            public override int GetHashCode(SetPropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(PropertyTypeHybridRowSerializer).Comparer.GetHashCode(obj.Items));
            }
        }
    }

    public readonly struct MapPropertyTypeHybridRowSerializer : IHybridRowSerializer<MapPropertyType>
    {
        public const int SchemaId = 2147473665;
        public const int Size = 0;
        public IEqualityComparer<MapPropertyType> Comparer => MapPropertyTypeComparer.Default;
        private static readonly Utf8String KeysName = Utf8String.TranscodeUtf16("keys");
        private static readonly Utf8String ValuesName = Utf8String.TranscodeUtf16("values");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn KeysColumn;
        private static readonly LayoutColumn ValuesColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken KeysToken;
        private static readonly StringToken ValuesToken;
        private static readonly StringToken __BaseToken;

        static MapPropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(KeysName, out KeysColumn);
            Contract.Invariant(found);
            found = layout.TryFind(ValuesName, out ValuesColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(KeysColumn.Path, out KeysToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(ValuesColumn.Path, out ValuesToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, MapPropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, MapPropertyType value)
        {
            Result r;
            if (value.Keys != default)
            {
                scope.Find(ref row, KeysColumn.Path);
                r = default(PropertyTypeHybridRowSerializer)
                    .Write(ref row, ref scope, false, KeysColumn.TypeArgs, value.Keys);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Values != default)
            {
                scope.Find(ref row, ValuesColumn.Path);
                r = default(PropertyTypeHybridRowSerializer)
                    .Write(ref row, ref scope, false, ValuesColumn.TypeArgs, value.Values);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out MapPropertyType value)
        {
            if (isRoot)
            {
                value = new MapPropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new MapPropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref MapPropertyType value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == KeysToken.Id)
                {
                    r = default(PropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out PropertyType fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Keys = fieldValue;
                    continue;
                }

                if (scope.Token == ValuesToken.Id)
                {
                    r = default(PropertyTypeHybridRowSerializer)
                        .Read(ref row, ref scope, false, out PropertyType fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Values = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class MapPropertyTypeComparer : EqualityComparer<MapPropertyType>
        {
            public static new readonly MapPropertyTypeComparer Default = new MapPropertyTypeComparer();

            public override bool Equals(MapPropertyType x, MapPropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(PropertyTypeHybridRowSerializer).Comparer.Equals(x.Keys, y.Keys) && 
                    default(PropertyTypeHybridRowSerializer).Comparer.Equals(x.Values, y.Values);
            }

            public override int GetHashCode(MapPropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(PropertyTypeHybridRowSerializer).Comparer.GetHashCode(obj.Keys),
                    default(PropertyTypeHybridRowSerializer).Comparer.GetHashCode(obj.Values));
            }
        }
    }

    public readonly struct TuplePropertyTypeHybridRowSerializer : IHybridRowSerializer<TuplePropertyType>
    {
        public const int SchemaId = 2147473666;
        public const int Size = 0;
        public IEqualityComparer<TuplePropertyType> Comparer => TuplePropertyTypeComparer.Default;
        private static readonly Utf8String ItemsName = Utf8String.TranscodeUtf16("items");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn ItemsColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken ItemsToken;
        private static readonly StringToken __BaseToken;

        static TuplePropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(ItemsName, out ItemsColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(ItemsColumn.Path, out ItemsToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, TuplePropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, TuplePropertyType value)
        {
            Result r;
            if ((value.Items != null) && (value.Items.Count > 0))
            {
                scope.Find(ref row, ItemsColumn.Path);
                r = default(ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    ItemsColumn.TypeArgs,
                    value.Items);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out TuplePropertyType value)
        {
            if (isRoot)
            {
                value = new TuplePropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new TuplePropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref TuplePropertyType value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == ItemsToken.Id)
                {
                    r = default(ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<PropertyType> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Items = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class TuplePropertyTypeComparer : EqualityComparer<TuplePropertyType>
        {
            public static new readonly TuplePropertyTypeComparer Default = new TuplePropertyTypeComparer();

            public override bool Equals(TuplePropertyType x, TuplePropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(TypedArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>).Comparer.Equals(x.Items, y.Items);
            }

            public override int GetHashCode(TuplePropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(TypedArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>).Comparer.GetHashCode(obj.Items));
            }
        }
    }

    public readonly struct TaggedPropertyTypeHybridRowSerializer : IHybridRowSerializer<TaggedPropertyType>
    {
        public const int SchemaId = 2147473667;
        public const int Size = 0;
        public IEqualityComparer<TaggedPropertyType> Comparer => TaggedPropertyTypeComparer.Default;
        private static readonly Utf8String ItemsName = Utf8String.TranscodeUtf16("items");
        private static readonly Utf8String __BaseName = Utf8String.TranscodeUtf16("__base");

        private static readonly LayoutColumn ItemsColumn;
        private static readonly LayoutColumn __BaseColumn;

        private static readonly StringToken ItemsToken;
        private static readonly StringToken __BaseToken;

        static TaggedPropertyTypeHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(ItemsName, out ItemsColumn);
            Contract.Invariant(found);
            found = layout.TryFind(__BaseName, out __BaseColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(ItemsColumn.Path, out ItemsToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(__BaseColumn.Path, out __BaseToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, TaggedPropertyType value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, TaggedPropertyType value)
        {
            Result r;
            if ((value.Items != null) && (value.Items.Count > 0))
            {
                scope.Find(ref row, ItemsColumn.Path);
                r = default(ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    ItemsColumn.TypeArgs,
                    value.Items);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            {
                scope.Find(ref row, __BaseColumn.Path);
                r = ScopePropertyTypeHybridRowSerializer.WriteBase(ref row, ref scope, value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out TaggedPropertyType value)
        {
            if (isRoot)
            {
                value = new TaggedPropertyType();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new TaggedPropertyType();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref TaggedPropertyType value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == ItemsToken.Id)
                {
                    r = default(ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<PropertyType> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Items = fieldValue;
                    continue;
                }

                if (scope.Token == __BaseToken.Id)
                {
                    ScopePropertyType baseValue = value;
                    r = ScopePropertyTypeHybridRowSerializer.ReadBase(ref row, ref scope, ref baseValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    Contract.Assert(baseValue == value);
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class TaggedPropertyTypeComparer : EqualityComparer<TaggedPropertyType>
        {
            public static new readonly TaggedPropertyTypeComparer Default = new TaggedPropertyTypeComparer();

            public override bool Equals(TaggedPropertyType x, TaggedPropertyType y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.EqualsBase(x, y) && 
                    default(TypedArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>).Comparer.Equals(x.Items, y.Items);
            }

            public override int GetHashCode(TaggedPropertyType obj)
            {
                return HashCode.Combine(
                    ScopePropertyTypeHybridRowSerializer.ScopePropertyTypeComparer.GetHashCodeBase(obj),
                    default(TypedArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>).Comparer.GetHashCode(obj.Items));
            }
        }
    }

    public readonly struct EnumSchemaHybridRowSerializer : IHybridRowSerializer<EnumSchema>
    {
        public const int SchemaId = 2147473668;
        public const int Size = 2;
        public IEqualityComparer<EnumSchema> Comparer => EnumSchemaComparer.Default;
        private static readonly Utf8String TypeName = Utf8String.TranscodeUtf16("type");
        private static readonly Utf8String NameName = Utf8String.TranscodeUtf16("name");
        private static readonly Utf8String CommentName = Utf8String.TranscodeUtf16("comment");
        private static readonly Utf8String ApiTypeName = Utf8String.TranscodeUtf16("apitype");
        private static readonly Utf8String ValuesName = Utf8String.TranscodeUtf16("values");

        private static readonly LayoutColumn TypeColumn;
        private static readonly LayoutColumn NameColumn;
        private static readonly LayoutColumn CommentColumn;
        private static readonly LayoutColumn ApiTypeColumn;
        private static readonly LayoutColumn ValuesColumn;

        private static readonly StringToken CommentToken;
        private static readonly StringToken ApiTypeToken;
        private static readonly StringToken ValuesToken;

        static EnumSchemaHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(TypeName, out TypeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(NameName, out NameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CommentName, out CommentColumn);
            Contract.Invariant(found);
            found = layout.TryFind(ApiTypeName, out ApiTypeColumn);
            Contract.Invariant(found);
            found = layout.TryFind(ValuesName, out ValuesColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(CommentColumn.Path, out CommentToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(ApiTypeColumn.Path, out ApiTypeToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(ValuesColumn.Path, out ValuesToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, EnumSchema value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, EnumSchema value)
        {
            Result r;
            if (value.Type != default)
            {
                r = LayoutType.UInt8.WriteFixed(ref row, ref scope, TypeColumn, (byte)value.Type);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Name != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, NameColumn, value.Name);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Comment != default)
            {
                scope.Find(ref row, CommentColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Comment);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.ApiType != default)
            {
                scope.Find(ref row, ApiTypeColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.ApiType);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if ((value.Values != null) && (value.Values.Count > 0))
            {
                scope.Find(ref row, ValuesColumn.Path);
                r = default(TypedArrayHybridRowSerializer<EnumValue, EnumValueHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    ValuesColumn.TypeArgs,
                    value.Values);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out EnumSchema value)
        {
            if (isRoot)
            {
                value = new EnumSchema();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new EnumSchema();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref EnumSchema value)
        {
            Result r;
            {
                r = LayoutType.UInt8.ReadFixed(ref row, ref scope, TypeColumn, out byte fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Type = (TypeKind)fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, NameColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Name = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == CommentToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Comment = fieldValue;
                    continue;
                }

                if (scope.Token == ApiTypeToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.ApiType = fieldValue;
                    continue;
                }

                if (scope.Token == ValuesToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<EnumValue, EnumValueHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<EnumValue> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Values = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class EnumSchemaComparer : EqualityComparer<EnumSchema>
        {
            public static new readonly EnumSchemaComparer Default = new EnumSchemaComparer();

            public override bool Equals(EnumSchema x, EnumSchema y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(UInt8HybridRowSerializer).Comparer.Equals((byte)x.Type, (byte)y.Type) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Name, y.Name) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Comment, y.Comment) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.ApiType, y.ApiType) && 
                    default(TypedArrayHybridRowSerializer<EnumValue, EnumValueHybridRowSerializer>).Comparer.Equals(x.Values, y.Values);
            }

            public override int GetHashCode(EnumSchema obj)
            {
                return HashCode.Combine(
                    default(UInt8HybridRowSerializer).Comparer.GetHashCode((byte)obj.Type),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Name),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Comment),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.ApiType),
                    default(TypedArrayHybridRowSerializer<EnumValue, EnumValueHybridRowSerializer>).Comparer.GetHashCode(obj.Values));
            }
        }
    }

    public readonly struct EnumValueHybridRowSerializer : IHybridRowSerializer<EnumValue>
    {
        public const int SchemaId = 2147473669;
        public const int Size = 9;
        public IEqualityComparer<EnumValue> Comparer => EnumValueComparer.Default;
        private static readonly Utf8String NameName = Utf8String.TranscodeUtf16("name");
        private static readonly Utf8String ValueName = Utf8String.TranscodeUtf16("value");
        private static readonly Utf8String CommentName = Utf8String.TranscodeUtf16("comment");

        private static readonly LayoutColumn NameColumn;
        private static readonly LayoutColumn ValueColumn;
        private static readonly LayoutColumn CommentColumn;

        private static readonly StringToken CommentToken;

        static EnumValueHybridRowSerializer()
        {
            Layout layout = SchemasHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(NameName, out NameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(ValueName, out ValueColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CommentName, out CommentColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(CommentColumn.Path, out CommentToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, EnumValue value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, EnumValue value)
        {
            Result r;
            if (value.Value != default)
            {
                r = LayoutType.Int64.WriteFixed(ref row, ref scope, ValueColumn, value.Value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Name != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, NameColumn, value.Name);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Comment != default)
            {
                scope.Find(ref row, CommentColumn.Path);
                r = LayoutType.Utf8.WriteSparse(ref row, ref scope, value.Comment);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out EnumValue value)
        {
            if (isRoot)
            {
                value = new EnumValue();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new EnumValue();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref EnumValue value)
        {
            Result r;
            {
                r = LayoutType.Int64.ReadFixed(ref row, ref scope, ValueColumn, out long fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Value = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, NameColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Name = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == CommentToken.Id)
                {
                    r = LayoutType.Utf8.ReadSparse(ref row, ref scope, out string fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Comment = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class EnumValueComparer : EqualityComparer<EnumValue>
        {
            public static new readonly EnumValueComparer Default = new EnumValueComparer();

            public override bool Equals(EnumValue x, EnumValue y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Name, y.Name) && 
                    default(Int64HybridRowSerializer).Comparer.Equals(x.Value, y.Value) && 
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Comment, y.Comment);
            }

            public override int GetHashCode(EnumValue obj)
            {
                return HashCode.Combine(
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Name),
                    default(Int64HybridRowSerializer).Comparer.GetHashCode(obj.Value),
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Comment));
            }
        }
    }
}
