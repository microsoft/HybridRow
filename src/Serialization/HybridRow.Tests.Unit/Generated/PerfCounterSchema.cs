// ------------------------------------------------------------
//  Copyright (c) Microsoft Corporation.  All rights reserved.
// ------------------------------------------------------------

// ------------------------------------------------------------
// This file was generated by:
//   Microsoft.Azure.Cosmos.Serialization.HybridRowCLI: 1.0.0.0
//
// This file should not be modified directly.
// ------------------------------------------------------------

#pragma warning disable NamespaceMatchesFolderStructure // Namespace Declarations must match folder structure.
#pragma warning disable CA1707 // Identifiers should not contain underscores.
#pragma warning disable CA1034 // Do not nest types.
#pragma warning disable CA2104 // Do not declare readonly mutable reference types.
#pragma warning disable SA1129 // Do not use default value type constructor.
#pragma warning disable SA1309 // Field should not begin with an underscore.
#pragma warning disable SA1310 // Field names should not contain underscore.
#pragma warning disable SA1402 // File may only contain a single type.
#pragma warning disable SA1414 // Tuple types in signatures should have element names.
#pragma warning disable SA1514 // Element documentation header should be preceded by blank line.
#pragma warning disable SA1516 // Elements should be separated by blank line.
#pragma warning disable SA1649 // File name should match first type name.

// ReSharper disable CheckNamespace
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantEmptySwitchSection
// ReSharper disable JoinDeclarationAndInitializer
// ReSharper disable TooWideLocalVariableScope
// ReSharper disable ArrangeStaticMemberQualifier
// ReSharper disable RedundantJumpStatement
// ReSharper disable RedundantUsingDirective
namespace Microsoft.Azure.Cosmos.Serialization.HybridRow.Tests.Unit.TypedTuple
{
    using System;
    using System.Collections.Generic;
    using System.Runtime.CompilerServices;
    using Microsoft.Azure.Cosmos.Core;
    using Microsoft.Azure.Cosmos.Core.Utf8;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.IO;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.Layouts;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.RecordIO;
    using Microsoft.Azure.Cosmos.Serialization.HybridRow.Schemas;

    internal static class TypedTupleHrSchema
    {
        public static readonly Namespace Namespace = TypedTupleHrSchema.CreateSchema();
        public static readonly LayoutResolver LayoutResolver = TypedTupleHrSchema.LoadSchema();

        private static Namespace CreateSchema()
        {
            return new Namespace
            {
                Name = "Microsoft.Azure.Cosmos.Serialization.HybridRow.Tests.Unit.TypedTuple",
                Version = SchemaLanguageVersion.V2,
                CppNamespace = "cdb_hr_test::tuple",
                Schemas = new List<Schema>
                {
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "Coord",
                        SchemaId = new SchemaId(2),
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "lat",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int64,
                                    Storage = StorageKind.Fixed,
                                },
                            },
                            new Property
                            {
                                Path = "lng",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Int64,
                                    Storage = StorageKind.Fixed,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "PerfCounter",
                        SchemaId = new SchemaId(1),
                        PartitionKeys = new List<PartitionKey>
                        {
                            new PartitionKey
                            {
                                Path = "name",
                            },
                        },
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "name",
                                PropertyType = new PrimitivePropertyType
                                {
                                    Type = TypeKind.Utf8,
                                    Storage = StorageKind.Variable,
                                },
                            },
                            new Property
                            {
                                Path = "value",
                                PropertyType = new TuplePropertyType
                                {
                                    Items = new List<PropertyType>
                                    {
                                        new PrimitivePropertyType
                                        {
                                            Type = TypeKind.Utf8,
                                            Nullable = false,
                                        },
                                        new PrimitivePropertyType
                                        {
                                            Type = TypeKind.Int64,
                                            Nullable = false,
                                        },
                                    },
                                    Immutable = true,
                                },
                            },
                            new Property
                            {
                                Path = "minmeanmax",
                                PropertyType = new TuplePropertyType
                                {
                                    Items = new List<PropertyType>
                                    {
                                        new PrimitivePropertyType
                                        {
                                            Type = TypeKind.Utf8,
                                            Nullable = false,
                                        },
                                        new TuplePropertyType
                                        {
                                            Items = new List<PropertyType>
                                            {
                                                new PrimitivePropertyType
                                                {
                                                    Type = TypeKind.Int64,
                                                    Nullable = false,
                                                },
                                                new PrimitivePropertyType
                                                {
                                                    Type = TypeKind.Int64,
                                                    Nullable = false,
                                                },
                                                new PrimitivePropertyType
                                                {
                                                    Type = TypeKind.Int64,
                                                    Nullable = false,
                                                },
                                            },
                                            Nullable = false,
                                        },
                                    },
                                    Immutable = true,
                                },
                                ApiName = "MinMaxValue",
                            },
                            new Property
                            {
                                Path = "coord",
                                PropertyType = new TuplePropertyType
                                {
                                    Items = new List<PropertyType>
                                    {
                                        new PrimitivePropertyType
                                        {
                                            Type = TypeKind.Utf8,
                                            Nullable = false,
                                        },
                                        new UdtPropertyType
                                        {
                                            Name = "Coord",
                                            SchemaId = new SchemaId(0),
                                            Nullable = false,
                                        },
                                    },
                                    Immutable = true,
                                },
                            },
                        },
                    },
                    //////////////////////////////////////////////////////////////////////////////
                    new Schema
                    {
                        Name = "CounterSet",
                        SchemaId = new SchemaId(3),
                        Properties = new List<Property>
                        {
                            new Property
                            {
                                Path = "history",
                                PropertyType = new ArrayPropertyType
                                {
                                    Items = new UdtPropertyType
                                    {
                                        Name = "PerfCounter",
                                        SchemaId = new SchemaId(0),
                                        Nullable = false,
                                    },
                                },
                            },
                        },
                    },
                },
            };
        }

        private static LayoutResolver LoadSchema()
        {
            return new LayoutResolverNamespace(TypedTupleHrSchema.Namespace);
        }
    }

    public sealed class Coord
    {
        public long Lat { get; set; }
        public long Lng { get; set; }
    }

    public sealed class PerfCounter
    {
        public string Name { get; set; }
        public (string, long) Value { get; set; }
        public (string, (long, long, long)) MinMaxValue { get; set; }
        public (string, Coord) Coord { get; set; }
    }

    public sealed class CounterSet
    {
        public List<PerfCounter> History { get; set; }
    }

    public readonly struct CoordHybridRowSerializer : IHybridRowSerializer<Coord>
    {
        public const int SchemaId = 2;
        public const int Size = 17;
        public IEqualityComparer<Coord> Comparer => CoordComparer.Default;
        private static readonly Utf8String LatName = Utf8String.TranscodeUtf16("lat");
        private static readonly Utf8String LngName = Utf8String.TranscodeUtf16("lng");

        private static readonly LayoutColumn LatColumn;
        private static readonly LayoutColumn LngColumn;

        static CoordHybridRowSerializer()
        {
            Layout layout = TypedTupleHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(LatName, out LatColumn);
            Contract.Invariant(found);
            found = layout.TryFind(LngName, out LngColumn);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, Coord value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, Coord value)
        {
            Result r;
            if (value.Lat != default)
            {
                r = LayoutType.Int64.WriteFixed(ref row, ref scope, LatColumn, value.Lat);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Lng != default)
            {
                r = LayoutType.Int64.WriteFixed(ref row, ref scope, LngColumn, value.Lng);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out Coord value)
        {
            if (isRoot)
            {
                value = new Coord();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new Coord();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref Coord value)
        {
            Result r;
            {
                r = LayoutType.Int64.ReadFixed(ref row, ref scope, LatColumn, out long fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Lat = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            {
                r = LayoutType.Int64.ReadFixed(ref row, ref scope, LngColumn, out long fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Lng = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            return Result.Success;
        }

        public sealed class CoordComparer : EqualityComparer<Coord>
        {
            public static new readonly CoordComparer Default = new CoordComparer();

            public override bool Equals(Coord x, Coord y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Int64HybridRowSerializer).Comparer.Equals(x.Lat, y.Lat) && 
                    default(Int64HybridRowSerializer).Comparer.Equals(x.Lng, y.Lng);
            }

            public override int GetHashCode(Coord obj)
            {
                return HashCode.Combine(
                    default(Int64HybridRowSerializer).Comparer.GetHashCode(obj.Lat),
                    default(Int64HybridRowSerializer).Comparer.GetHashCode(obj.Lng));
            }
        }
    }

    public readonly struct PerfCounterHybridRowSerializer : IHybridRowSerializer<PerfCounter>
    {
        public const int SchemaId = 1;
        public const int Size = 1;
        public IEqualityComparer<PerfCounter> Comparer => PerfCounterComparer.Default;
        private static readonly Utf8String NameName = Utf8String.TranscodeUtf16("name");
        private static readonly Utf8String ValueName = Utf8String.TranscodeUtf16("value");
        private static readonly Utf8String MinMaxValueName = Utf8String.TranscodeUtf16("minmeanmax");
        private static readonly Utf8String CoordName = Utf8String.TranscodeUtf16("coord");

        private static readonly LayoutColumn NameColumn;
        private static readonly LayoutColumn ValueColumn;
        private static readonly LayoutColumn MinMaxValueColumn;
        private static readonly LayoutColumn CoordColumn;

        private static readonly StringToken ValueToken;
        private static readonly StringToken MinMaxValueToken;
        private static readonly StringToken CoordToken;

        static PerfCounterHybridRowSerializer()
        {
            Layout layout = TypedTupleHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(NameName, out NameColumn);
            Contract.Invariant(found);
            found = layout.TryFind(ValueName, out ValueColumn);
            Contract.Invariant(found);
            found = layout.TryFind(MinMaxValueName, out MinMaxValueColumn);
            Contract.Invariant(found);
            found = layout.TryFind(CoordName, out CoordColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(ValueColumn.Path, out ValueToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(MinMaxValueColumn.Path, out MinMaxValueToken);
            Contract.Invariant(found);
            found = layout.Tokenizer.TryFindToken(CoordColumn.Path, out CoordToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, PerfCounter value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, PerfCounter value)
        {
            Result r;
            if (value.Name != default)
            {
                r = LayoutType.Utf8.WriteVariable(ref row, ref scope, NameColumn, value.Name);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Value != default)
            {
                scope.Find(ref row, ValueColumn.Path);
                r = default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, long, Int64HybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    ValueColumn.TypeArgs,
                    value.Value);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.MinMaxValue != default)
            {
                scope.Find(ref row, MinMaxValueColumn.Path);
                r = default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, (long, long, long), TypedTupleHybridRowSerializer<long, Int64HybridRowSerializer, long, Int64HybridRowSerializer, long, Int64HybridRowSerializer>>).Write(
                    ref row,
                    ref scope,
                    false,
                    MinMaxValueColumn.TypeArgs,
                    value.MinMaxValue);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            if (value.Coord != default)
            {
                scope.Find(ref row, CoordColumn.Path);
                r = default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, Coord, CoordHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    CoordColumn.TypeArgs,
                    value.Coord);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out PerfCounter value)
        {
            if (isRoot)
            {
                value = new PerfCounter();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new PerfCounter();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref PerfCounter value)
        {
            Result r;
            {
                r = LayoutType.Utf8.ReadVariable(ref row, ref scope, NameColumn, out string fieldValue);
                switch (r)
                {
                    case Result.NotFound:
                        break;
                    case Result.Success:
                        value.Name = fieldValue;
                        break;
                    default:
                        return r;
                }
            }

            while (scope.MoveNext(ref row))
            {
                if (scope.Token == ValueToken.Id)
                {
                    r = default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, long, Int64HybridRowSerializer>)
                        .Read(ref row, ref scope, false, out (string, long) fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Value = fieldValue;
                    continue;
                }

                if (scope.Token == MinMaxValueToken.Id)
                {
                    r = default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, (long, long, long), TypedTupleHybridRowSerializer<long, Int64HybridRowSerializer, long, Int64HybridRowSerializer, long, Int64HybridRowSerializer>>)
                        .Read(ref row, ref scope, false, out (string, (long, long, long)) fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.MinMaxValue = fieldValue;
                    continue;
                }

                if (scope.Token == CoordToken.Id)
                {
                    r = default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, Coord, CoordHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out (string, Coord) fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.Coord = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class PerfCounterComparer : EqualityComparer<PerfCounter>
        {
            public static new readonly PerfCounterComparer Default = new PerfCounterComparer();

            public override bool Equals(PerfCounter x, PerfCounter y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return
                    default(Utf8HybridRowSerializer).Comparer.Equals(x.Name, y.Name) && 
                    default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, long, Int64HybridRowSerializer>).Comparer.Equals(x.Value, y.Value) && 
                    default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, (long, long, long), TypedTupleHybridRowSerializer<long, Int64HybridRowSerializer, long, Int64HybridRowSerializer, long, Int64HybridRowSerializer>>).Comparer.Equals(x.MinMaxValue, y.MinMaxValue) && 
                    default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, Coord, CoordHybridRowSerializer>).Comparer.Equals(x.Coord, y.Coord);
            }

            public override int GetHashCode(PerfCounter obj)
            {
                return HashCode.Combine(
                    default(Utf8HybridRowSerializer).Comparer.GetHashCode(obj.Name),
                    default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, long, Int64HybridRowSerializer>).Comparer.GetHashCode(obj.Value),
                    default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, (long, long, long), TypedTupleHybridRowSerializer<long, Int64HybridRowSerializer, long, Int64HybridRowSerializer, long, Int64HybridRowSerializer>>).Comparer.GetHashCode(obj.MinMaxValue),
                    default(TypedTupleHybridRowSerializer<string, Utf8HybridRowSerializer, Coord, CoordHybridRowSerializer>).Comparer.GetHashCode(obj.Coord));
            }
        }
    }

    public readonly struct CounterSetHybridRowSerializer : IHybridRowSerializer<CounterSet>
    {
        public const int SchemaId = 3;
        public const int Size = 0;
        public IEqualityComparer<CounterSet> Comparer => CounterSetComparer.Default;
        private static readonly Utf8String HistoryName = Utf8String.TranscodeUtf16("history");

        private static readonly LayoutColumn HistoryColumn;

        private static readonly StringToken HistoryToken;

        static CounterSetHybridRowSerializer()
        {
            Layout layout = TypedTupleHrSchema.LayoutResolver.Resolve(new SchemaId(SchemaId));

            bool found;
            found = layout.TryFind(HistoryName, out HistoryColumn);
            Contract.Invariant(found);

            found = layout.Tokenizer.TryFindToken(HistoryColumn.Path, out HistoryToken);
            Contract.Invariant(found);
        }

        public Result Write(ref RowBuffer row, ref RowCursor scope, bool isRoot, TypeArgumentList typeArgs, CounterSet value)
        {
            if (isRoot)
            {
                return Write(ref row, ref scope, value);
            }

            Result r = LayoutType.UDT.WriteScope(ref row, ref scope, new SchemaId(SchemaId), out RowCursor childScope);
            if (r != Result.Success)
            {
                return r;
            }

            r = Write(ref row, ref childScope, value);
            if (r != Result.Success)
            {
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Write(ref RowBuffer row, ref RowCursor scope, CounterSet value)
        {
            Result r;
            if (value.History != default)
            {
                scope.Find(ref row, HistoryColumn.Path);
                r = default(TypedArrayHybridRowSerializer<PerfCounter, PerfCounterHybridRowSerializer>).Write(
                    ref row,
                    ref scope,
                    false,
                    HistoryColumn.TypeArgs,
                    value.History);
                if (r != Result.Success)
                {
                    return r;
                }
            }

            return Result.Success;
        }

        public Result Read(ref RowBuffer row, ref RowCursor scope, bool isRoot, out CounterSet value)
        {
            if (isRoot)
            {
                value = new CounterSet();
                return Read(ref row, ref scope, ref value);
            }

            Result r = LayoutType.UDT.ReadScope(ref row, ref scope, out RowCursor childScope);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            value = new CounterSet();
            r = Read(ref row, ref childScope, ref value);
            if (r != Result.Success)
            {
                value = default;
                return r;
            }

            scope.Skip(ref row, ref childScope);
            return Result.Success;
        }

        private static Result Read(ref RowBuffer row, ref RowCursor scope, ref CounterSet value)
        {
            Result r;
            while (scope.MoveNext(ref row))
            {
                if (scope.Token == HistoryToken.Id)
                {
                    r = default(TypedArrayHybridRowSerializer<PerfCounter, PerfCounterHybridRowSerializer>)
                        .Read(ref row, ref scope, false, out List<PerfCounter> fieldValue);
                    if (r != Result.Success)
                    {
                        return r;
                    }

                    value.History = fieldValue;
                    continue;
                }
            }

            return Result.Success;
        }

        public sealed class CounterSetComparer : EqualityComparer<CounterSet>
        {
            public static new readonly CounterSetComparer Default = new CounterSetComparer();

            public override bool Equals(CounterSet x, CounterSet y)
            {
                HybridRowSerializer.EqualityReferenceResult refCheck = HybridRowSerializer.EqualityReferenceCheck(x, y);
                if (refCheck != HybridRowSerializer.EqualityReferenceResult.Unknown)
                {
                    return refCheck == HybridRowSerializer.EqualityReferenceResult.Equal;
                }

                return default(TypedArrayHybridRowSerializer<PerfCounter, PerfCounterHybridRowSerializer>).Comparer.Equals(x.History, y.History);
            }

            public override int GetHashCode(CounterSet obj)
            {
                return default(TypedArrayHybridRowSerializer<PerfCounter, PerfCounterHybridRowSerializer>).Comparer.GetHashCode(obj.History);
            }
        }
    }
}
