// ------------------------------------------------------------
//  Copyright (c) Microsoft Corporation.  All rights reserved.
// ------------------------------------------------------------

#pragma once

// ------------------------------------------------------------
// This file was generated by:
//   Microsoft.Azure.Cosmos.Serialization.HybridRowCLI: 1.0.0.0
//
// This file should not be modified directly.
// ------------------------------------------------------------

namespace cdb_hr
{
  class Segment;
  class Record;
  class Namespace;
  class Schema;
  class SchemaOptions;
  class PartitionKey;
  class PrimarySortKey;
  class StaticKey;
  class Property;
  class PropertyType;
  class PrimitivePropertyType;
  class ScopePropertyType;
  class ArrayPropertyType;
  class ObjectPropertyType;
  class UdtPropertyType;
  class SetPropertyType;
  class MapPropertyType;
  class TuplePropertyType;
  class TaggedPropertyType;
  class EnumSchema;
  class EnumValue;

  struct SchemasHrSchema final
  {
    static const cdb_hr::Namespace& GetNamespace() noexcept;
    static const cdb_hr::LayoutResolver& GetLayoutResolver() noexcept;

  private:
    class Literal;
  };

  struct SegmentHybridRowSerializer final
  {
    using value_type = Segment;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473648};
    constexpr static uint32_t Size{5};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const Segment& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<Segment>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<Segment, SegmentHybridRowSerializer>);

  struct RecordHybridRowSerializer final
  {
    using value_type = Record;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473649};
    constexpr static uint32_t Size{8};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const Record& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<Record>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<Record, RecordHybridRowSerializer>);

  struct NamespaceHybridRowSerializer final
  {
    using value_type = Namespace;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473651};
    constexpr static uint32_t Size{2};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const Namespace& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<Namespace>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<Namespace, NamespaceHybridRowSerializer>);

  struct SchemaHybridRowSerializer final
  {
    using value_type = Schema;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473652};
    constexpr static uint32_t Size{7};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const Schema& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<Schema>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<Schema, SchemaHybridRowSerializer>);

  /// <summary>
  /// Describes the set of options that apply to the entire schema and the way it is validated.
  /// </summary>
  struct SchemaOptionsHybridRowSerializer final
  {
    using value_type = SchemaOptions;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473653};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const SchemaOptions& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<SchemaOptions>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<SchemaOptions, SchemaOptionsHybridRowSerializer>);

  struct PartitionKeyHybridRowSerializer final
  {
    using value_type = PartitionKey;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473654};
    constexpr static uint32_t Size{1};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const PartitionKey& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<PartitionKey>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<PartitionKey, PartitionKeyHybridRowSerializer>);

  struct PrimarySortKeyHybridRowSerializer final
  {
    using value_type = PrimarySortKey;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473655};
    constexpr static uint32_t Size{2};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const PrimarySortKey& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<PrimarySortKey>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<PrimarySortKey, PrimarySortKeyHybridRowSerializer>);

  struct StaticKeyHybridRowSerializer final
  {
    using value_type = StaticKey;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473656};
    constexpr static uint32_t Size{1};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const StaticKey& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<StaticKey>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<StaticKey, StaticKeyHybridRowSerializer>);

  struct PropertyHybridRowSerializer final
  {
    using value_type = Property;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473657};
    constexpr static uint32_t Size{1};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const Property& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<Property>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<Property, PropertyHybridRowSerializer>);

  struct PropertyTypeHybridRowSerializer final
  {
    using value_type = PropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473658};
    constexpr static uint32_t Size{2};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const PropertyType& value) noexcept;
    static cdb_hr::Result WriteBase(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<PropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);
    static cdb_hr::Result ReadBase(const RowBuffer& row, RowCursor& scope, PropertyType& value);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<PropertyType, PropertyTypeHybridRowSerializer>);

  struct PrimitivePropertyTypeHybridRowSerializer final
  {
    using value_type = PrimitivePropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473659};
    constexpr static uint32_t Size{5};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const PrimitivePropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<PrimitivePropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<PrimitivePropertyType, PrimitivePropertyTypeHybridRowSerializer>);

  struct ScopePropertyTypeHybridRowSerializer final
  {
    using value_type = ScopePropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473660};
    constexpr static uint32_t Size{1};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const ScopePropertyType& value) noexcept;
    static cdb_hr::Result WriteBase(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ScopePropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<ScopePropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);
    static cdb_hr::Result ReadBase(const RowBuffer& row, RowCursor& scope, ScopePropertyType& value);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<ScopePropertyType, ScopePropertyTypeHybridRowSerializer>);

  struct ArrayPropertyTypeHybridRowSerializer final
  {
    using value_type = ArrayPropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473661};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const ArrayPropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<ArrayPropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<ArrayPropertyType, ArrayPropertyTypeHybridRowSerializer>);

  struct ObjectPropertyTypeHybridRowSerializer final
  {
    using value_type = ObjectPropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473662};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const ObjectPropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<ObjectPropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<ObjectPropertyType, ObjectPropertyTypeHybridRowSerializer>);

  struct UdtPropertyTypeHybridRowSerializer final
  {
    using value_type = UdtPropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473663};
    constexpr static uint32_t Size{5};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const UdtPropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<UdtPropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<UdtPropertyType, UdtPropertyTypeHybridRowSerializer>);

  struct SetPropertyTypeHybridRowSerializer final
  {
    using value_type = SetPropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473664};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const SetPropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<SetPropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<SetPropertyType, SetPropertyTypeHybridRowSerializer>);

  struct MapPropertyTypeHybridRowSerializer final
  {
    using value_type = MapPropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473665};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const MapPropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<MapPropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<MapPropertyType, MapPropertyTypeHybridRowSerializer>);

  struct TuplePropertyTypeHybridRowSerializer final
  {
    using value_type = TuplePropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473666};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const TuplePropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<TuplePropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<TuplePropertyType, TuplePropertyTypeHybridRowSerializer>);

  struct TaggedPropertyTypeHybridRowSerializer final
  {
    using value_type = TaggedPropertyType;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473667};
    constexpr static uint32_t Size{0};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const TaggedPropertyType& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<TaggedPropertyType>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<TaggedPropertyType, TaggedPropertyTypeHybridRowSerializer>);

  struct EnumSchemaHybridRowSerializer final
  {
    using value_type = EnumSchema;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473668};
    constexpr static uint32_t Size{2};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const EnumSchema& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<EnumSchema>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<EnumSchema, EnumSchemaHybridRowSerializer>);

  struct EnumValueHybridRowSerializer final
  {
    using value_type = EnumValue;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2147473669};
    constexpr static uint32_t Size{9};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const EnumValue& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<EnumValue>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<EnumValue, EnumValueHybridRowSerializer>);
}
