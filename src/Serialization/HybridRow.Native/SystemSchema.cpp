// ------------------------------------------------------------
//  Copyright (c) Microsoft Corporation.  All rights reserved.
// ------------------------------------------------------------

#include "pch.h"
#include "HybridRow.Native.h"
#include "SystemSchema.h"

// ------------------------------------------------------------
// This file was generated by:
//   Microsoft.Azure.Cosmos.Serialization.HybridRowCLI: 1.0.0.0
//
// This file should not be modified directly.
// ------------------------------------------------------------

// ReSharper disable CppClangTidyCppcoreguidelinesProTypeStaticCastDowncast
// ReSharper disable CppClangTidyPerformanceMoveConstArg
// ReSharper disable CppRedundantControlFlowJump
// ReSharper disable CppClangTidyClangDiagnosticExitTimeDestructors
namespace cdb_hr
{
  using namespace std::literals;

  class SchemasHrSchema::Literal final
  {
    friend struct SchemasHrSchema;


    static const cdb_hr::Namespace& GetNamespace() noexcept
    {
      return *s_namespace;
    }

    static std::unique_ptr<cdb_hr::LayoutResolver> LoadSchema()
    {
      auto ns = cdb_core::make_unique_with([&](cdb_hr::Namespace& n)
      {
        n.SetName("Microsoft.Azure.Cosmos.Serialization.HybridRow.Schemas");
        n.SetVersion(cdb_hr::SchemaLanguageVersion::V2);
        n.SetCppNamespace("cdb_hr");
        //////////////////////////////////////////////////////////////////////////////
        n.GetEnums().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumSchema& es)
        {
          es.SetName("SchemaLanguageVersion");
          es.SetComment("Versions of the HybridRow Schema Description Language.");
          es.SetType(cdb_hr::TypeKind::UInt8);
          es.GetValues().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumValue& ev)
          {
            ev.SetName("V1");
            ev.SetComment("Initial version of the HybridRow Schema Description Language.");
            ev.SetValue(0);
          }));
          es.GetValues().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumValue& ev)
          {
            ev.SetName("V2");
            ev.SetComment("Introduced Enums, Inheritance.");
            ev.SetValue(2);
          }));
          es.GetValues().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumValue& ev)
          {
            ev.SetName("Unspecified");
            ev.SetComment("No version is specified.");
            ev.SetValue(255);
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetEnums().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumSchema& es)
        {
          es.SetName("TypeKind");
          es.SetComment("Describes the logical type of a property.");
          es.SetType(cdb_hr::TypeKind::UInt8);
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetEnums().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumSchema& es)
        {
          es.SetName("StorageKind");
          es.SetComment("Describes the storage placement for primitive properties.");
          es.SetType(cdb_hr::TypeKind::UInt8);
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetEnums().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumSchema& es)
        {
          es.SetName("SortDirection");
          es.SetComment("Describes the sort order direction.");
          es.SetType(cdb_hr::TypeKind::UInt8);
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetEnums().emplace_back(cdb_core::make_unique_with([](cdb_hr::EnumSchema& es)
        {
          es.SetName("AllowEmptyKind");
          es.SetComment("Describes the empty canonicalization for properties.");
          es.SetType(cdb_hr::TypeKind::UInt8);
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("EmptySchema");
          s.SetSchemaId(cdb_hr::SchemaId{2147473650});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("Segment");
          s.SetSchemaId(cdb_hr::SchemaId{2147473648});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("length");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int32);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetRowBufferSize(true);
            }));
            p.SetComment("(Required) length (in bytes) of this RecordIO segment header itself.  Does NOT include the length of the records that follow.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("comment");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("A comment describing the data in this RecordIO segment.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("sdl");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("A HybridRow Schema in SDL (json-format).");
            p.SetApiName("SDL");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("schema");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("Namespace", cdb_hr::SchemaId{2147473651}));
            p.SetComment("A HybridRow Schema.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("Record");
          s.SetSchemaId(cdb_hr::SchemaId{2147473649});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("length");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int32);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetNullable(false);
            }));
            p.SetComment("(Required) length (in bytes) of the HybridRow value that follows this record header.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("crc32");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::UInt32);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetNullable(false);
            }));
            p.SetComment("(Optional) CRC-32 as described in ISO 3309.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("Namespace");
          s.SetSchemaId(cdb_hr::SchemaId{2147473651});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("version");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("SchemaLanguageVersion");
              pt.SetNullable(false);
            }));
            p.SetComment("(Required) SDL language version.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("name");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
            p.SetComment("(Optional) Name of the namespace.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("comment");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("(Optional) Comment field describing the namespace.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("schemas");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("Schema", cdb_hr::SchemaId{2147473652}, false)));
            p.SetComment("The set of schemas that make up the namespace.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("enums");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("EnumSchema", cdb_hr::SchemaId{2147473668}, false)));
            p.SetComment("The set of enums defined in the namespace.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("cppNamespace");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("An (optional) namespace to use when performing C++ codegen.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("Schema");
          s.SetSchemaId(cdb_hr::SchemaId{2147473652});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("version");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("SchemaLanguageVersion");
              pt.SetNullable(false);
            }));
            p.SetComment("(Optional) SDL language version.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("type");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("TypeKind");
              pt.SetNullable(false);
            }));
            p.SetComment("(Required) Type of the schema element.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("id");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int32);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetApiType("SchemaId");
              pt.SetNullable(false);
            }));
            p.SetComment("(Required) Globally unique id of the schema.");
            p.SetApiName("SchemaId");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("name");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
            p.SetComment("(Optional) Name of the schema.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("comment");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("(Optional) Comment field describing the schema.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("options");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("SchemaOptions", cdb_hr::SchemaId{2147473653}));
            p.SetComment("(Optional) Schema options.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("partitionKeys");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("PartitionKey", cdb_hr::SchemaId{2147473654}, false)));
            p.SetComment("(Optional) List of zero or more logical paths that form the partition key.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("primaryKeys");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("PrimarySortKey", cdb_hr::SchemaId{2147473655}, false)));
            p.SetComment("(Optional) List of zero or more logical paths that form the primary sort key.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("staticKeys");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("StaticKey", cdb_hr::SchemaId{2147473656}, false)));
            p.SetComment("(Optional) List of zero or more logical paths that hold data shared by all documents that have the same partition key.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("properties");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("Property", cdb_hr::SchemaId{2147473657}, false)));
            p.SetComment("(Optional) List of zero or more property definitions that define the columns within the schema.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("baseName");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("The name of the schema this schema derives from.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("baseId");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int32);
              pt.SetApiType("SchemaId");
            }));
            p.SetComment("The unique identifier of the schema this schema derives from.");
            p.SetApiName("BaseSchemaId");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("SchemaOptions");
          s.SetSchemaId(cdb_hr::SchemaId{2147473653});
          s.SetComment("Describes the set of options that apply to the entire schema and the way it is validated.");
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("disallowUnschematized");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("enablePropertyLevelTimestamp");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("disableSystemPrefix");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("abstract");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
            }));
            p.SetComment("If true then instances of this schema cannot be created directly, only through subtypes.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("PartitionKey");
          s.SetSchemaId(cdb_hr::SchemaId{2147473654});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("path");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("PrimarySortKey");
          s.SetSchemaId(cdb_hr::SchemaId{2147473655});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("path");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("direction");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("SortDirection");
              pt.SetNullable(false);
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("StaticKey");
          s.SetSchemaId(cdb_hr::SchemaId{2147473656});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("path");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("Property");
          s.SetSchemaId(cdb_hr::SchemaId{2147473657});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("path");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("comment");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("type");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}));
            p.SetComment("The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.");
            p.SetApiName("PropertyType");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("apiname");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetApiName("ApiName");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("allowEmpty");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetEnum("AllowEmptyKind");
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("PropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473658});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
            so.SetAbstract(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("apitype");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
            p.SetApiName("ApiType");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("type");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("TypeKind");
              pt.SetNullable(false);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("nullable");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetNullable(false);
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("PrimitivePropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473659});
          s.SetBaseName("PropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473658});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("length");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int32);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetNullable(false);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("storage");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("StorageKind");
              pt.SetNullable(false);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("enum");
            p.SetAllowEmpty(AllowEmptyKind::EmptyAsNull);
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("rowBufferSize");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("ScopePropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetBaseName("PropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473658});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
            so.SetAbstract(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("immutable");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Boolean);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetNullable(false);
            }));
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("ArrayPropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473661});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("items");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}));
            p.SetComment("The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("ObjectPropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473662});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("properties");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("Property", cdb_hr::SchemaId{2147473657}, false)));
            p.SetComment("(Optional) List of zero or more property definitions that define the columns within the schema.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("UdtPropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473663});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("name");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("id");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int32);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetApiType("SchemaId");
              pt.SetNullable(false);
            }));
            p.SetApiName("SchemaId");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("SetPropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473664});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("items");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}));
            p.SetComment("The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("MapPropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473665});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("keys");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}));
            p.SetComment("The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("values");
            p.SetPropertyType(
              std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}));
            p.SetComment("The type of the property. This field is polymorphic and may contain any defined subtype of PropertyType.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("TuplePropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473666});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("items");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}, false)));
            p.SetComment("The type of the properties. This field is polymorphic and may contain any defined subtype of PropertyType.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("TaggedPropertyType");
          s.SetSchemaId(cdb_hr::SchemaId{2147473667});
          s.SetBaseName("ScopePropertyType");
          s.SetBaseSchemaId(cdb_hr::SchemaId{2147473660});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("items");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("PropertyType", cdb_hr::SchemaId{2147473658}, false)));
            p.SetComment("The type of the properties. This field is polymorphic and may contain any defined subtype of PropertyType.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("EnumSchema");
          s.SetSchemaId(cdb_hr::SchemaId{2147473668});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("type");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Enum);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
              pt.SetEnum("TypeKind");
              pt.SetNullable(false);
            }));
            p.SetComment("(Required) Type of the schema element.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("name");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
            p.SetComment("(Optional) Name of the schema.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("comment");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("(Optional) Comment field describing the schema.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("apitype");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("Api-specific type annotations for the property.");
            p.SetApiName("ApiType");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("values");
            p.SetAllowEmpty(AllowEmptyKind::Both);
            p.SetPropertyType(
              std::make_unique<cdb_hr::ArrayPropertyType>(
                std::make_unique<cdb_hr::UdtPropertyType>("EnumValue", cdb_hr::SchemaId{2147473669}, false)));
            p.SetComment("(Optional) List of zero or more values.");
          }));
        }));
        //////////////////////////////////////////////////////////////////////////////
        n.GetSchemas().emplace_back(cdb_core::make_unique_with([](cdb_hr::Schema& s)
        {
          s.SetName("EnumValue");
          s.SetSchemaId(cdb_hr::SchemaId{2147473669});
          s.SetOptions(cdb_core::make_unique_with([](cdb_hr::SchemaOptions& so)
          {
            so.SetDisallowUnschematized(true);
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("name");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
              pt.SetStorage(cdb_hr::StorageKind::Variable);
            }));
            p.SetComment("(Optional) Name of the schema.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("value");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Int64);
              pt.SetStorage(cdb_hr::StorageKind::Fixed);
            }));
            p.SetComment("The numerical value of the enum value.");
          }));
          s.GetProperties().emplace_back(cdb_core::make_unique_with([](cdb_hr::Property& p)
          {
            p.SetPath("comment");
            p.SetPropertyType(cdb_core::make_unique_with([](cdb_hr::PrimitivePropertyType& pt)
            {
              pt.SetType(cdb_hr::TypeKind::Utf8);
            }));
            p.SetComment("(Optional) Comment field describing the schema.");
          }));
        }));
      });

      s_namespace = ns.get();
      return std::make_unique<cdb_hr::LayoutResolverNamespace>(std::move(ns));
    }

    inline static cdb_hr::Namespace* s_namespace{nullptr};
    inline static std::unique_ptr<cdb_hr::LayoutResolver> s_layoutResolver{LoadSchema()};
  };

  const cdb_hr::Namespace& SchemasHrSchema::GetNamespace() noexcept
  {
    return *Literal::s_namespace;
  }

  const cdb_hr::LayoutResolver& SchemasHrSchema::GetLayoutResolver() noexcept
  {
    return *Literal::s_layoutResolver;
  }

  class SegmentHybridRowSerializer::Literal final
  {
    friend struct SegmentHybridRowSerializer;

    constexpr static std::string_view LengthName{"length"sv};
    constexpr static std::string_view CommentName{"comment"sv};
    constexpr static std::string_view SDLName{"sdl"sv};
    constexpr static std::string_view SchemaName{"schema"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& LengthColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, LengthName)};
    inline static const cdb_hr::LayoutColumn& CommentColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CommentName)};
    inline static const cdb_hr::LayoutColumn& SDLColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, SDLName)};
    inline static const cdb_hr::LayoutColumn& SchemaColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, SchemaName)};

    inline static const cdb_hr::StringTokenizer::StringToken& CommentToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CommentColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& SDLToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, SDLColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& SchemaToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, SchemaColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Segment& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Segment& value);
  };

  cdb_hr::Result SegmentHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const Segment& value) noexcept
  {
    if (isRoot)
    {
      return SegmentHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = SegmentHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result SegmentHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Segment& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetComment()))
    {
      scope.Find(row, CommentColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetComment()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetSDL()))
    {
      scope.Find(row, SDLColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetSDL()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetSchema()))
    {
      scope.Find(row, SchemaColumn.GetPath());
      cdb_hr::Result r = NamespaceHybridRowSerializer::Write(
        row, scope, false, SchemaColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetSchema()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    // Emit RowBufferSize field with actual size of RowBuffer.
    cdb_hr::Result r = cdb_hr::LayoutLiteral::Int32.WriteFixed(
      row, scope, LengthColumn, static_cast<int32_t>(row.GetLength()));
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<Segment>> SegmentHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<Segment> value = std::make_unique<Segment>();
      cdb_hr::Result r = SegmentHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Segment>{}};
    }

    std::unique_ptr<Segment> value = std::make_unique<Segment>();
    r = SegmentHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Segment>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result SegmentHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Segment& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int32.ReadFixed(row, scope, LengthColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetLength(fieldValue);
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == CommentToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetComment(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == SDLToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetSDL(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == SchemaToken.GetId())
      {
        auto [r, fieldValue] = NamespaceHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetSchema(std::move(fieldValue));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class RecordHybridRowSerializer::Literal final
  {
    friend struct RecordHybridRowSerializer;

    constexpr static std::string_view LengthName{"length"sv};
    constexpr static std::string_view Crc32Name{"crc32"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& LengthColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, LengthName)};
    inline static const cdb_hr::LayoutColumn& Crc32Column{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, Crc32Name)};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Record& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Record& value);
  };

  cdb_hr::Result RecordHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const Record& value) noexcept
  {
    if (isRoot)
    {
      return RecordHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = RecordHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result RecordHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Record& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetLength()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Int32.WriteFixed(
        row, scope, LengthColumn, cdb_hr::IHybridRowSerializer::get(value.GetLength()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetCrc32()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt32.WriteFixed(
        row, scope, Crc32Column, cdb_hr::IHybridRowSerializer::get(value.GetCrc32()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<Record>> RecordHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<Record> value = std::make_unique<Record>();
      cdb_hr::Result r = RecordHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Record>{}};
    }

    std::unique_ptr<Record> value = std::make_unique<Record>();
    r = RecordHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Record>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result RecordHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Record& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int32.ReadFixed(row, scope, LengthColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetLength(fieldValue);
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt32.ReadFixed(row, scope, Crc32Column);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetCrc32(fieldValue);
        break;
      default:
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  class NamespaceHybridRowSerializer::Literal final
  {
    friend struct NamespaceHybridRowSerializer;

    constexpr static std::string_view VersionName{"version"sv};
    constexpr static std::string_view NameName{"name"sv};
    constexpr static std::string_view CommentName{"comment"sv};
    constexpr static std::string_view SchemasName{"schemas"sv};
    constexpr static std::string_view EnumsName{"enums"sv};
    constexpr static std::string_view CppNamespaceName{"cppNamespace"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& VersionColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, VersionName)};
    inline static const cdb_hr::LayoutColumn& NameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, NameName)};
    inline static const cdb_hr::LayoutColumn& CommentColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CommentName)};
    inline static const cdb_hr::LayoutColumn& SchemasColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, SchemasName)};
    inline static const cdb_hr::LayoutColumn& EnumsColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, EnumsName)};
    inline static const cdb_hr::LayoutColumn& CppNamespaceColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CppNamespaceName)};

    inline static const cdb_hr::StringTokenizer::StringToken& CommentToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CommentColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& SchemasToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, SchemasColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& EnumsToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, EnumsColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& CppNamespaceToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CppNamespaceColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Namespace& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Namespace& value);
  };

  cdb_hr::Result NamespaceHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const Namespace& value) noexcept
  {
    if (isRoot)
    {
      return NamespaceHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = NamespaceHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result NamespaceHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Namespace& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetVersion()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, VersionColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetVersion())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetName()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, NameColumn, cdb_hr::IHybridRowSerializer::get(value.GetName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetComment()))
    {
      scope.Find(row, CommentColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetComment()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetSchemas()))
    {
      scope.Find(row, SchemasColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<Schema, SchemaHybridRowSerializer>::Write(
        row,
        scope,
        false,
        SchemasColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetSchemas()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetEnums()))
    {
      scope.Find(row, EnumsColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<EnumSchema, EnumSchemaHybridRowSerializer>::Write(
        row,
        scope,
        false,
        EnumsColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetEnums()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetCppNamespace()))
    {
      scope.Find(row, CppNamespaceColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetCppNamespace()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<Namespace>> NamespaceHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<Namespace> value = std::make_unique<Namespace>();
      cdb_hr::Result r = NamespaceHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Namespace>{}};
    }

    std::unique_ptr<Namespace> value = std::make_unique<Namespace>();
    r = NamespaceHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Namespace>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result NamespaceHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Namespace& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, VersionColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetVersion(static_cast<SchemaLanguageVersion>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, NameColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetName(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == CommentToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetComment(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == SchemasToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<Schema, SchemaHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetSchemas(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == EnumsToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<EnumSchema, EnumSchemaHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetEnums(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == CppNamespaceToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetCppNamespace(std::move(fieldValue));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class SchemaHybridRowSerializer::Literal final
  {
    friend struct SchemaHybridRowSerializer;

    constexpr static std::string_view VersionName{"version"sv};
    constexpr static std::string_view TypeName{"type"sv};
    constexpr static std::string_view SchemaIdName{"id"sv};
    constexpr static std::string_view NameName{"name"sv};
    constexpr static std::string_view CommentName{"comment"sv};
    constexpr static std::string_view OptionsName{"options"sv};
    constexpr static std::string_view PartitionKeysName{"partitionKeys"sv};
    constexpr static std::string_view PrimaryKeysName{"primaryKeys"sv};
    constexpr static std::string_view StaticKeysName{"staticKeys"sv};
    constexpr static std::string_view PropertiesName{"properties"sv};
    constexpr static std::string_view BaseNameName{"baseName"sv};
    constexpr static std::string_view BaseSchemaIdName{"baseId"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& VersionColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, VersionName)};
    inline static const cdb_hr::LayoutColumn& TypeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, TypeName)};
    inline static const cdb_hr::LayoutColumn& SchemaIdColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, SchemaIdName)};
    inline static const cdb_hr::LayoutColumn& NameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, NameName)};
    inline static const cdb_hr::LayoutColumn& CommentColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CommentName)};
    inline static const cdb_hr::LayoutColumn& OptionsColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, OptionsName)};
    inline static const cdb_hr::LayoutColumn& PartitionKeysColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PartitionKeysName)};
    inline static const cdb_hr::LayoutColumn& PrimaryKeysColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PrimaryKeysName)};
    inline static const cdb_hr::LayoutColumn& StaticKeysColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, StaticKeysName)};
    inline static const cdb_hr::LayoutColumn& PropertiesColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PropertiesName)};
    inline static const cdb_hr::LayoutColumn& BaseNameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, BaseNameName)};
    inline static const cdb_hr::LayoutColumn& BaseSchemaIdColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, BaseSchemaIdName)};

    inline static const cdb_hr::StringTokenizer::StringToken& CommentToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CommentColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& OptionsToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, OptionsColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& PartitionKeysToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, PartitionKeysColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& PrimaryKeysToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, PrimaryKeysColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& StaticKeysToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, StaticKeysColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& PropertiesToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, PropertiesColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& BaseNameToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, BaseNameColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& BaseSchemaIdToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, BaseSchemaIdColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Schema& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Schema& value);
  };

  cdb_hr::Result SchemaHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const Schema& value) noexcept
  {
    if (isRoot)
    {
      return SchemaHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = SchemaHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result SchemaHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Schema& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetVersion()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, VersionColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetVersion())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetType()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, TypeColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetType())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetSchemaId()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Int32.WriteFixed(
        row, scope, SchemaIdColumn, static_cast<int32_t>(cdb_hr::IHybridRowSerializer::get(value.GetSchemaId())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetName()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, NameColumn, cdb_hr::IHybridRowSerializer::get(value.GetName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetComment()))
    {
      scope.Find(row, CommentColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetComment()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetOptions()))
    {
      scope.Find(row, OptionsColumn.GetPath());
      cdb_hr::Result r = SchemaOptionsHybridRowSerializer::Write(
        row, scope, false, OptionsColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetOptions()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetPartitionKeys()))
    {
      scope.Find(row, PartitionKeysColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<PartitionKey, PartitionKeyHybridRowSerializer>::Write(
        row,
        scope,
        false,
        PartitionKeysColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetPartitionKeys()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetPrimaryKeys()))
    {
      scope.Find(row, PrimaryKeysColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<PrimarySortKey, PrimarySortKeyHybridRowSerializer>::Write(
        row,
        scope,
        false,
        PrimaryKeysColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetPrimaryKeys()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetStaticKeys()))
    {
      scope.Find(row, StaticKeysColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<StaticKey, StaticKeyHybridRowSerializer>::Write(
        row,
        scope,
        false,
        StaticKeysColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetStaticKeys()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetProperties()))
    {
      scope.Find(row, PropertiesColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>::Write(
        row,
        scope,
        false,
        PropertiesColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetProperties()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetBaseName()))
    {
      scope.Find(row, BaseNameColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetBaseName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetBaseSchemaId()))
    {
      scope.Find(row, BaseSchemaIdColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Int32.WriteSparse(
        row, scope, static_cast<int32_t>(cdb_hr::IHybridRowSerializer::get(value.GetBaseSchemaId())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<Schema>> SchemaHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<Schema> value = std::make_unique<Schema>();
      cdb_hr::Result r = SchemaHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Schema>{}};
    }

    std::unique_ptr<Schema> value = std::make_unique<Schema>();
    r = SchemaHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Schema>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result SchemaHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Schema& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, VersionColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetVersion(static_cast<SchemaLanguageVersion>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, TypeColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetType(static_cast<TypeKind>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int32.ReadFixed(row, scope, SchemaIdColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetSchemaId(static_cast<SchemaId>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, NameColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetName(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == CommentToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetComment(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == OptionsToken.GetId())
      {
        auto [r, fieldValue] = SchemaOptionsHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetOptions(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == PartitionKeysToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<PartitionKey, PartitionKeyHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetPartitionKeys(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == PrimaryKeysToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<PrimarySortKey, PrimarySortKeyHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetPrimaryKeys(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == StaticKeysToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<StaticKey, StaticKeyHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetStaticKeys(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == PropertiesToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetProperties(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == BaseNameToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetBaseName(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == BaseSchemaIdToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int32.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetBaseSchemaId(static_cast<SchemaId>(std::move(fieldValue)));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class SchemaOptionsHybridRowSerializer::Literal final
  {
    friend struct SchemaOptionsHybridRowSerializer;

    constexpr static std::string_view DisallowUnschematizedName{"disallowUnschematized"sv};
    constexpr static std::string_view EnablePropertyLevelTimestampName{"enablePropertyLevelTimestamp"sv};
    constexpr static std::string_view DisableSystemPrefixName{"disableSystemPrefix"sv};
    constexpr static std::string_view AbstractName{"abstract"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& DisallowUnschematizedColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, DisallowUnschematizedName)};
    inline static const cdb_hr::LayoutColumn& EnablePropertyLevelTimestampColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, EnablePropertyLevelTimestampName)};
    inline static const cdb_hr::LayoutColumn& DisableSystemPrefixColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, DisableSystemPrefixName)};
    inline static const cdb_hr::LayoutColumn& AbstractColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, AbstractName)};

    inline static const cdb_hr::StringTokenizer::StringToken& DisallowUnschematizedToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, DisallowUnschematizedColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& EnablePropertyLevelTimestampToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, EnablePropertyLevelTimestampColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& DisableSystemPrefixToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, DisableSystemPrefixColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& AbstractToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, AbstractColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const SchemaOptions& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, SchemaOptions& value);
  };

  cdb_hr::Result SchemaOptionsHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const SchemaOptions& value) noexcept
  {
    if (isRoot)
    {
      return SchemaOptionsHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = SchemaOptionsHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result SchemaOptionsHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const SchemaOptions& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetDisallowUnschematized()))
    {
      scope.Find(row, DisallowUnschematizedColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetDisallowUnschematized()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetEnablePropertyLevelTimestamp()))
    {
      scope.Find(row, EnablePropertyLevelTimestampColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetEnablePropertyLevelTimestamp()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetDisableSystemPrefix()))
    {
      scope.Find(row, DisableSystemPrefixColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetDisableSystemPrefix()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetAbstract()))
    {
      scope.Find(row, AbstractColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetAbstract()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<SchemaOptions>> SchemaOptionsHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<SchemaOptions> value = std::make_unique<SchemaOptions>();
      cdb_hr::Result r = SchemaOptionsHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<SchemaOptions>{}};
    }

    std::unique_ptr<SchemaOptions> value = std::make_unique<SchemaOptions>();
    r = SchemaOptionsHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<SchemaOptions>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result SchemaOptionsHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, SchemaOptions& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == DisallowUnschematizedToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetDisallowUnschematized(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == EnablePropertyLevelTimestampToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetEnablePropertyLevelTimestamp(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == DisableSystemPrefixToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetDisableSystemPrefix(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == AbstractToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetAbstract(std::move(fieldValue));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class PartitionKeyHybridRowSerializer::Literal final
  {
    friend struct PartitionKeyHybridRowSerializer;

    constexpr static std::string_view PathName{"path"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& PathColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PathName)};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PartitionKey& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PartitionKey& value);
  };

  cdb_hr::Result PartitionKeyHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const PartitionKey& value) noexcept
  {
    if (isRoot)
    {
      return PartitionKeyHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = PartitionKeyHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result PartitionKeyHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PartitionKey& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetPath()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, PathColumn, cdb_hr::IHybridRowSerializer::get(value.GetPath()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<PartitionKey>> PartitionKeyHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<PartitionKey> value = std::make_unique<PartitionKey>();
      cdb_hr::Result r = PartitionKeyHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<PartitionKey>{}};
    }

    std::unique_ptr<PartitionKey> value = std::make_unique<PartitionKey>();
    r = PartitionKeyHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<PartitionKey>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result PartitionKeyHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PartitionKey& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, PathColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetPath(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  class PrimarySortKeyHybridRowSerializer::Literal final
  {
    friend struct PrimarySortKeyHybridRowSerializer;

    constexpr static std::string_view PathName{"path"sv};
    constexpr static std::string_view DirectionName{"direction"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& PathColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PathName)};
    inline static const cdb_hr::LayoutColumn& DirectionColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, DirectionName)};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PrimarySortKey& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PrimarySortKey& value);
  };

  cdb_hr::Result PrimarySortKeyHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const PrimarySortKey& value) noexcept
  {
    if (isRoot)
    {
      return PrimarySortKeyHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = PrimarySortKeyHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result PrimarySortKeyHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PrimarySortKey& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetDirection()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, DirectionColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetDirection())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetPath()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, PathColumn, cdb_hr::IHybridRowSerializer::get(value.GetPath()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<PrimarySortKey>> PrimarySortKeyHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<PrimarySortKey> value = std::make_unique<PrimarySortKey>();
      cdb_hr::Result r = PrimarySortKeyHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<PrimarySortKey>{}};
    }

    std::unique_ptr<PrimarySortKey> value = std::make_unique<PrimarySortKey>();
    r = PrimarySortKeyHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<PrimarySortKey>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result PrimarySortKeyHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PrimarySortKey& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, DirectionColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetDirection(static_cast<SortDirection>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, PathColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetPath(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  class StaticKeyHybridRowSerializer::Literal final
  {
    friend struct StaticKeyHybridRowSerializer;

    constexpr static std::string_view PathName{"path"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& PathColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PathName)};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const StaticKey& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, StaticKey& value);
  };

  cdb_hr::Result StaticKeyHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const StaticKey& value) noexcept
  {
    if (isRoot)
    {
      return StaticKeyHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = StaticKeyHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result StaticKeyHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const StaticKey& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetPath()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, PathColumn, cdb_hr::IHybridRowSerializer::get(value.GetPath()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<StaticKey>> StaticKeyHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<StaticKey> value = std::make_unique<StaticKey>();
      cdb_hr::Result r = StaticKeyHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<StaticKey>{}};
    }

    std::unique_ptr<StaticKey> value = std::make_unique<StaticKey>();
    r = StaticKeyHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<StaticKey>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result StaticKeyHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, StaticKey& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, PathColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetPath(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  class PropertyHybridRowSerializer::Literal final
  {
    friend struct PropertyHybridRowSerializer;

    constexpr static std::string_view PathName{"path"sv};
    constexpr static std::string_view CommentName{"comment"sv};
    constexpr static std::string_view PropertyTypeName{"type"sv};
    constexpr static std::string_view ApiNameName{"apiname"sv};
    constexpr static std::string_view AllowEmptyName{"allowEmpty"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& PathColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PathName)};
    inline static const cdb_hr::LayoutColumn& CommentColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CommentName)};
    inline static const cdb_hr::LayoutColumn& PropertyTypeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PropertyTypeName)};
    inline static const cdb_hr::LayoutColumn& ApiNameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ApiNameName)};
    inline static const cdb_hr::LayoutColumn& AllowEmptyColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, AllowEmptyName)};

    inline static const cdb_hr::StringTokenizer::StringToken& CommentToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CommentColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& PropertyTypeToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, PropertyTypeColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& ApiNameToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ApiNameColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& AllowEmptyToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, AllowEmptyColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Property& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Property& value);
  };

  cdb_hr::Result PropertyHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const Property& value) noexcept
  {
    if (isRoot)
    {
      return PropertyHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = PropertyHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result PropertyHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const Property& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetPath()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, PathColumn, cdb_hr::IHybridRowSerializer::get(value.GetPath()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetComment()))
    {
      scope.Find(row, CommentColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetComment()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetPropertyType()))
    {
      scope.Find(row, PropertyTypeColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::Write(
        row, scope, false, PropertyTypeColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetPropertyType()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetApiName()))
    {
      scope.Find(row, ApiNameColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetApiName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetAllowEmpty()))
    {
      scope.Find(row, AllowEmptyColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteSparse(
        row, scope, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetAllowEmpty())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<Property>> PropertyHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<Property> value = std::make_unique<Property>();
      cdb_hr::Result r = PropertyHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Property>{}};
    }

    std::unique_ptr<Property> value = std::make_unique<Property>();
    r = PropertyHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<Property>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result PropertyHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, Property& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, PathColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetPath(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == CommentToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetComment(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == PropertyTypeToken.GetId())
      {
        auto [r, fieldValue] = PropertyTypeHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetPropertyType(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == ApiNameToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetApiName(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == AllowEmptyToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetAllowEmpty(static_cast<AllowEmptyKind>(std::move(fieldValue)));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class PropertyTypeHybridRowSerializer::Literal final
  {
    friend struct PropertyTypeHybridRowSerializer;

    constexpr static std::string_view ApiTypeName{"apitype"sv};
    constexpr static std::string_view TypeName{"type"sv};
    constexpr static std::string_view NullableName{"nullable"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& ApiTypeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ApiTypeName)};
    inline static const cdb_hr::LayoutColumn& TypeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, TypeName)};
    inline static const cdb_hr::LayoutColumn& NullableColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, NullableName)};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PropertyType& value);
  };

  cdb_hr::Result PropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const PropertyType& value) noexcept
  {
    switch (value.GetRuntimeSchemaId().Id())
    {
    case PrimitivePropertyTypeHybridRowSerializer::Id.Id():
    {
      return PrimitivePropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const PrimitivePropertyType&>(value));
    }

    case ArrayPropertyTypeHybridRowSerializer::Id.Id():
    case ObjectPropertyTypeHybridRowSerializer::Id.Id():
    case UdtPropertyTypeHybridRowSerializer::Id.Id():
    case SetPropertyTypeHybridRowSerializer::Id.Id():
    case MapPropertyTypeHybridRowSerializer::Id.Id():
    case TuplePropertyTypeHybridRowSerializer::Id.Id():
    case TaggedPropertyTypeHybridRowSerializer::Id.Id():
    case ScopePropertyTypeHybridRowSerializer::Id.Id():
    {
      return ScopePropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const ScopePropertyType&>(value));
    }

    default:
      break;
    }

    cdb_core::Contract::Fail("Type is abstract.");
  }

  cdb_hr::Result PropertyTypeHybridRowSerializer::WriteBase(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PropertyType& value) noexcept
  {
    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = PropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result PropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetType()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, TypeColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetType())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetNullable()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteFixed(
        row, scope, NullableColumn, cdb_hr::IHybridRowSerializer::get(value.GetNullable()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetApiType()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, ApiTypeColumn, cdb_hr::IHybridRowSerializer::get(value.GetApiType()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<PropertyType>> PropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (!(scope.GetTypeArg().GetType()->IsUDT()))
    {
      return {cdb_hr::Result::TypeMismatch, std::unique_ptr<PropertyType>{}};
    }

    switch (scope.GetTypeArg().GetTypeArgs().GetSchemaId().Id())
    {
    case PrimitivePropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = PrimitivePropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case ArrayPropertyTypeHybridRowSerializer::Id.Id():
    case ObjectPropertyTypeHybridRowSerializer::Id.Id():
    case UdtPropertyTypeHybridRowSerializer::Id.Id():
    case SetPropertyTypeHybridRowSerializer::Id.Id():
    case MapPropertyTypeHybridRowSerializer::Id.Id():
    case TuplePropertyTypeHybridRowSerializer::Id.Id():
    case TaggedPropertyTypeHybridRowSerializer::Id.Id():
    case ScopePropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = ScopePropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    default:
      break;
    }

    cdb_core::Contract::Fail("Type is abstract.");
  }

  cdb_hr::Result PropertyTypeHybridRowSerializer::ReadBase(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PropertyType& value)
  {
    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = PropertyTypeHybridRowSerializer::Literal::Read(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result PropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PropertyType& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, TypeColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetType(static_cast<TypeKind>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadFixed(row, scope, NullableColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetNullable(fieldValue);
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, ApiTypeColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetApiType(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  class PrimitivePropertyTypeHybridRowSerializer::Literal final
  {
    friend struct PrimitivePropertyTypeHybridRowSerializer;

    constexpr static std::string_view LengthName{"length"sv};
    constexpr static std::string_view StorageName{"storage"sv};
    constexpr static std::string_view EnumName{"enum"sv};
    constexpr static std::string_view RowBufferSizeName{"rowBufferSize"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& LengthColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, LengthName)};
    inline static const cdb_hr::LayoutColumn& StorageColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, StorageName)};
    inline static const cdb_hr::LayoutColumn& EnumColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, EnumName)};
    inline static const cdb_hr::LayoutColumn& RowBufferSizeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, RowBufferSizeName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& EnumToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, EnumColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& RowBufferSizeToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, RowBufferSizeColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PrimitivePropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PrimitivePropertyType& value);
  };

  cdb_hr::Result PrimitivePropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const PrimitivePropertyType& value) noexcept
  {
    if (isRoot)
    {
      return PrimitivePropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = PrimitivePropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result PrimitivePropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const PrimitivePropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetLength()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Int32.WriteFixed(
        row, scope, LengthColumn, cdb_hr::IHybridRowSerializer::get(value.GetLength()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetStorage()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, StorageColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetStorage())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetEnum()))
    {
      scope.Find(row, EnumColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetEnum()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetRowBufferSize()))
    {
      scope.Find(row, RowBufferSizeColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetRowBufferSize()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<PrimitivePropertyType>> PrimitivePropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<PrimitivePropertyType> value = std::make_unique<PrimitivePropertyType>();
      cdb_hr::Result r = PrimitivePropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<PrimitivePropertyType>{}};
    }

    std::unique_ptr<PrimitivePropertyType> value = std::make_unique<PrimitivePropertyType>();
    r = PrimitivePropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<PrimitivePropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result PrimitivePropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, PrimitivePropertyType& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int32.ReadFixed(row, scope, LengthColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetLength(fieldValue);
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, StorageColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetStorage(static_cast<StorageKind>(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == EnumToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetEnum(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == RowBufferSizeToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetRowBufferSize(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = PropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class ScopePropertyTypeHybridRowSerializer::Literal final
  {
    friend struct ScopePropertyTypeHybridRowSerializer;

    constexpr static std::string_view ImmutableName{"immutable"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& ImmutableColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ImmutableName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ScopePropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ScopePropertyType& value);
  };

  cdb_hr::Result ScopePropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const ScopePropertyType& value) noexcept
  {
    switch (value.GetRuntimeSchemaId().Id())
    {
    case ArrayPropertyTypeHybridRowSerializer::Id.Id():
    {
      return ArrayPropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const ArrayPropertyType&>(value));
    }

    case ObjectPropertyTypeHybridRowSerializer::Id.Id():
    {
      return ObjectPropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const ObjectPropertyType&>(value));
    }

    case UdtPropertyTypeHybridRowSerializer::Id.Id():
    {
      return UdtPropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const UdtPropertyType&>(value));
    }

    case SetPropertyTypeHybridRowSerializer::Id.Id():
    {
      return SetPropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const SetPropertyType&>(value));
    }

    case MapPropertyTypeHybridRowSerializer::Id.Id():
    {
      return MapPropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const MapPropertyType&>(value));
    }

    case TuplePropertyTypeHybridRowSerializer::Id.Id():
    {
      return TuplePropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const TuplePropertyType&>(value));
    }

    case TaggedPropertyTypeHybridRowSerializer::Id.Id():
    {
      return TaggedPropertyTypeHybridRowSerializer::Write(row, scope, isRoot, typeArgs,
        static_cast<const TaggedPropertyType&>(value));
    }

    default:
      break;
    }

    cdb_core::Contract::Fail("Type is abstract.");
  }

  cdb_hr::Result ScopePropertyTypeHybridRowSerializer::WriteBase(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ScopePropertyType& value) noexcept
  {
    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = ScopePropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result ScopePropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ScopePropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetImmutable()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Boolean.WriteFixed(
        row, scope, ImmutableColumn, cdb_hr::IHybridRowSerializer::get(value.GetImmutable()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<ScopePropertyType>> ScopePropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (!(scope.GetTypeArg().GetType()->IsUDT()))
    {
      return {cdb_hr::Result::TypeMismatch, std::unique_ptr<ScopePropertyType>{}};
    }

    switch (scope.GetTypeArg().GetTypeArgs().GetSchemaId().Id())
    {
    case ArrayPropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = ArrayPropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case ObjectPropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = ObjectPropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case UdtPropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = UdtPropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case SetPropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = SetPropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case MapPropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = MapPropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case TuplePropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = TuplePropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    case TaggedPropertyTypeHybridRowSerializer::Id.Id():
    {
      auto [r, fieldValue] = TaggedPropertyTypeHybridRowSerializer::Read(row, scope, false);
      return {r, std::move(fieldValue)};
    }

    default:
      break;
    }

    cdb_core::Contract::Fail("Type is abstract.");
  }

  cdb_hr::Result ScopePropertyTypeHybridRowSerializer::ReadBase(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ScopePropertyType& value)
  {
    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = ScopePropertyTypeHybridRowSerializer::Literal::Read(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result ScopePropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ScopePropertyType& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Boolean.ReadFixed(row, scope, ImmutableColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetImmutable(fieldValue);
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = PropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class ArrayPropertyTypeHybridRowSerializer::Literal final
  {
    friend struct ArrayPropertyTypeHybridRowSerializer;

    constexpr static std::string_view ItemsName{"items"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& ItemsColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ItemsName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& ItemsToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ItemsColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ArrayPropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ArrayPropertyType& value);
  };

  cdb_hr::Result ArrayPropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const ArrayPropertyType& value) noexcept
  {
    if (isRoot)
    {
      return ArrayPropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = ArrayPropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result ArrayPropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ArrayPropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetItems()))
    {
      scope.Find(row, ItemsColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::Write(
        row, scope, false, ItemsColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetItems()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<ArrayPropertyType>> ArrayPropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<ArrayPropertyType> value = std::make_unique<ArrayPropertyType>();
      cdb_hr::Result r = ArrayPropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<ArrayPropertyType>{}};
    }

    std::unique_ptr<ArrayPropertyType> value = std::make_unique<ArrayPropertyType>();
    r = ArrayPropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<ArrayPropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result ArrayPropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ArrayPropertyType& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == ItemsToken.GetId())
      {
        auto [r, fieldValue] = PropertyTypeHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetItems(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class ObjectPropertyTypeHybridRowSerializer::Literal final
  {
    friend struct ObjectPropertyTypeHybridRowSerializer;

    constexpr static std::string_view PropertiesName{"properties"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& PropertiesColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, PropertiesName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& PropertiesToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, PropertiesColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ObjectPropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ObjectPropertyType& value);
  };

  cdb_hr::Result ObjectPropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const ObjectPropertyType& value) noexcept
  {
    if (isRoot)
    {
      return ObjectPropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = ObjectPropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result ObjectPropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const ObjectPropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetProperties()))
    {
      scope.Find(row, PropertiesColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>::Write(
        row,
        scope,
        false,
        PropertiesColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetProperties()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<ObjectPropertyType>> ObjectPropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<ObjectPropertyType> value = std::make_unique<ObjectPropertyType>();
      cdb_hr::Result r = ObjectPropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<ObjectPropertyType>{}};
    }

    std::unique_ptr<ObjectPropertyType> value = std::make_unique<ObjectPropertyType>();
    r = ObjectPropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<ObjectPropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result ObjectPropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, ObjectPropertyType& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == PropertiesToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<Property, PropertyHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetProperties(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class UdtPropertyTypeHybridRowSerializer::Literal final
  {
    friend struct UdtPropertyTypeHybridRowSerializer;

    constexpr static std::string_view NameName{"name"sv};
    constexpr static std::string_view SchemaIdName{"id"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& NameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, NameName)};
    inline static const cdb_hr::LayoutColumn& SchemaIdColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, SchemaIdName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const UdtPropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, UdtPropertyType& value);
  };

  cdb_hr::Result UdtPropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const UdtPropertyType& value) noexcept
  {
    if (isRoot)
    {
      return UdtPropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = UdtPropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result UdtPropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const UdtPropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetSchemaId()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Int32.WriteFixed(
        row, scope, SchemaIdColumn, static_cast<int32_t>(cdb_hr::IHybridRowSerializer::get(value.GetSchemaId())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetName()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, NameColumn, cdb_hr::IHybridRowSerializer::get(value.GetName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<UdtPropertyType>> UdtPropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<UdtPropertyType> value = std::make_unique<UdtPropertyType>();
      cdb_hr::Result r = UdtPropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<UdtPropertyType>{}};
    }

    std::unique_ptr<UdtPropertyType> value = std::make_unique<UdtPropertyType>();
    r = UdtPropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<UdtPropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result UdtPropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, UdtPropertyType& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int32.ReadFixed(row, scope, SchemaIdColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetSchemaId(static_cast<SchemaId>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, NameColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetName(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class SetPropertyTypeHybridRowSerializer::Literal final
  {
    friend struct SetPropertyTypeHybridRowSerializer;

    constexpr static std::string_view ItemsName{"items"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& ItemsColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ItemsName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& ItemsToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ItemsColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const SetPropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, SetPropertyType& value);
  };

  cdb_hr::Result SetPropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const SetPropertyType& value) noexcept
  {
    if (isRoot)
    {
      return SetPropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = SetPropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result SetPropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const SetPropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetItems()))
    {
      scope.Find(row, ItemsColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::Write(
        row, scope, false, ItemsColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetItems()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<SetPropertyType>> SetPropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<SetPropertyType> value = std::make_unique<SetPropertyType>();
      cdb_hr::Result r = SetPropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<SetPropertyType>{}};
    }

    std::unique_ptr<SetPropertyType> value = std::make_unique<SetPropertyType>();
    r = SetPropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<SetPropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result SetPropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, SetPropertyType& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == ItemsToken.GetId())
      {
        auto [r, fieldValue] = PropertyTypeHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetItems(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class MapPropertyTypeHybridRowSerializer::Literal final
  {
    friend struct MapPropertyTypeHybridRowSerializer;

    constexpr static std::string_view KeysName{"keys"sv};
    constexpr static std::string_view ValuesName{"values"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& KeysColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, KeysName)};
    inline static const cdb_hr::LayoutColumn& ValuesColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ValuesName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& KeysToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, KeysColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& ValuesToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ValuesColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const MapPropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, MapPropertyType& value);
  };

  cdb_hr::Result MapPropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const MapPropertyType& value) noexcept
  {
    if (isRoot)
    {
      return MapPropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = MapPropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result MapPropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const MapPropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetKeys()))
    {
      scope.Find(row, KeysColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::Write(
        row, scope, false, KeysColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetKeys()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetValues()))
    {
      scope.Find(row, ValuesColumn.GetPath());
      cdb_hr::Result r = PropertyTypeHybridRowSerializer::Write(
        row, scope, false, ValuesColumn.GetTypeArgs(), cdb_hr::IHybridRowSerializer::get(value.GetValues()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<MapPropertyType>> MapPropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<MapPropertyType> value = std::make_unique<MapPropertyType>();
      cdb_hr::Result r = MapPropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<MapPropertyType>{}};
    }

    std::unique_ptr<MapPropertyType> value = std::make_unique<MapPropertyType>();
    r = MapPropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<MapPropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result MapPropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, MapPropertyType& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == KeysToken.GetId())
      {
        auto [r, fieldValue] = PropertyTypeHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetKeys(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == ValuesToken.GetId())
      {
        auto [r, fieldValue] = PropertyTypeHybridRowSerializer::Read(row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetValues(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class TuplePropertyTypeHybridRowSerializer::Literal final
  {
    friend struct TuplePropertyTypeHybridRowSerializer;

    constexpr static std::string_view ItemsName{"items"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& ItemsColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ItemsName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& ItemsToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ItemsColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const TuplePropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, TuplePropertyType& value);
  };

  cdb_hr::Result TuplePropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const TuplePropertyType& value) noexcept
  {
    if (isRoot)
    {
      return TuplePropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = TuplePropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result TuplePropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const TuplePropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetItems()))
    {
      scope.Find(row, ItemsColumn.GetPath());
      cdb_hr::Result r = cdb_hr::ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>::Write(
        row,
        scope,
        false,
        ItemsColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetItems()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<TuplePropertyType>> TuplePropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<TuplePropertyType> value = std::make_unique<TuplePropertyType>();
      cdb_hr::Result r = TuplePropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<TuplePropertyType>{}};
    }

    std::unique_ptr<TuplePropertyType> value = std::make_unique<TuplePropertyType>();
    r = TuplePropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<TuplePropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result TuplePropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, TuplePropertyType& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == ItemsToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetItems(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class TaggedPropertyTypeHybridRowSerializer::Literal final
  {
    friend struct TaggedPropertyTypeHybridRowSerializer;

    constexpr static std::string_view ItemsName{"items"sv};
    constexpr static std::string_view __BaseName{"__base"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& ItemsColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ItemsName)};
    inline static const cdb_hr::LayoutColumn& __BaseColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, __BaseName)};

    inline static const cdb_hr::StringTokenizer::StringToken& ItemsToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ItemsColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& __BaseToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, __BaseColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const TaggedPropertyType& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, TaggedPropertyType& value);
  };

  cdb_hr::Result TaggedPropertyTypeHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const TaggedPropertyType& value) noexcept
  {
    if (isRoot)
    {
      return TaggedPropertyTypeHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = TaggedPropertyTypeHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result TaggedPropertyTypeHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const TaggedPropertyType& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetItems()))
    {
      scope.Find(row, ItemsColumn.GetPath());
      cdb_hr::Result r = cdb_hr::ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>::Write(
        row,
        scope,
        false,
        ItemsColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetItems()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    {
      scope.Find(row, __BaseColumn.GetPath());
      cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::WriteBase(row, scope, value);
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<TaggedPropertyType>> TaggedPropertyTypeHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<TaggedPropertyType> value = std::make_unique<TaggedPropertyType>();
      cdb_hr::Result r = TaggedPropertyTypeHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<TaggedPropertyType>{}};
    }

    std::unique_ptr<TaggedPropertyType> value = std::make_unique<TaggedPropertyType>();
    r = TaggedPropertyTypeHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<TaggedPropertyType>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result TaggedPropertyTypeHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, TaggedPropertyType& value)
  {
    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == ItemsToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::ArrayHybridRowSerializer<PropertyType, PropertyTypeHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetItems(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == __BaseToken.GetId())
      {
        cdb_hr::Result r = ScopePropertyTypeHybridRowSerializer::ReadBase(row, scope, value);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class EnumSchemaHybridRowSerializer::Literal final
  {
    friend struct EnumSchemaHybridRowSerializer;

    constexpr static std::string_view TypeName{"type"sv};
    constexpr static std::string_view NameName{"name"sv};
    constexpr static std::string_view CommentName{"comment"sv};
    constexpr static std::string_view ApiTypeName{"apitype"sv};
    constexpr static std::string_view ValuesName{"values"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& TypeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, TypeName)};
    inline static const cdb_hr::LayoutColumn& NameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, NameName)};
    inline static const cdb_hr::LayoutColumn& CommentColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CommentName)};
    inline static const cdb_hr::LayoutColumn& ApiTypeColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ApiTypeName)};
    inline static const cdb_hr::LayoutColumn& ValuesColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ValuesName)};

    inline static const cdb_hr::StringTokenizer::StringToken& CommentToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CommentColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& ApiTypeToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ApiTypeColumn.GetPath())
    };
    inline static const cdb_hr::StringTokenizer::StringToken& ValuesToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, ValuesColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const EnumSchema& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, EnumSchema& value);
  };

  cdb_hr::Result EnumSchemaHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const EnumSchema& value) noexcept
  {
    if (isRoot)
    {
      return EnumSchemaHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = EnumSchemaHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result EnumSchemaHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const EnumSchema& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetType()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::UInt8.WriteFixed(
        row, scope, TypeColumn, static_cast<uint8_t>(cdb_hr::IHybridRowSerializer::get(value.GetType())));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetName()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, NameColumn, cdb_hr::IHybridRowSerializer::get(value.GetName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetComment()))
    {
      scope.Find(row, CommentColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetComment()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetApiType()))
    {
      scope.Find(row, ApiTypeColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetApiType()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default_or_empty(value.GetValues()))
    {
      scope.Find(row, ValuesColumn.GetPath());
      cdb_hr::Result r = cdb_hr::TypedArrayHybridRowSerializer<EnumValue, EnumValueHybridRowSerializer>::Write(
        row,
        scope,
        false,
        ValuesColumn.GetTypeArgs(),
        cdb_hr::IHybridRowSerializer::get(value.GetValues()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<EnumSchema>> EnumSchemaHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<EnumSchema> value = std::make_unique<EnumSchema>();
      cdb_hr::Result r = EnumSchemaHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<EnumSchema>{}};
    }

    std::unique_ptr<EnumSchema> value = std::make_unique<EnumSchema>();
    r = EnumSchemaHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<EnumSchema>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result EnumSchemaHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, EnumSchema& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::UInt8.ReadFixed(row, scope, TypeColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetType(static_cast<TypeKind>(fieldValue));
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, NameColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetName(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == CommentToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetComment(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == ApiTypeToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetApiType(std::move(fieldValue));
        continue;
      }

      if (scope.GetToken() == ValuesToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::TypedArrayHybridRowSerializer<EnumValue, EnumValueHybridRowSerializer>::Read(
          row, scope, false);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetValues(std::move(fieldValue));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }

  class EnumValueHybridRowSerializer::Literal final
  {
    friend struct EnumValueHybridRowSerializer;

    constexpr static std::string_view NameName{"name"sv};
    constexpr static std::string_view ValueName{"value"sv};
    constexpr static std::string_view CommentName{"comment"sv};

    inline static const cdb_hr::Layout& Layout{SchemasHrSchema::GetLayoutResolver().Resolve(Id)};

    inline static const cdb_hr::LayoutColumn& NameColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, NameName)};
    inline static const cdb_hr::LayoutColumn& ValueColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, ValueName)};
    inline static const cdb_hr::LayoutColumn& CommentColumn{cdb_hr::IHybridRowSerializer::InitLayoutColumn(Layout, CommentName)};

    inline static const cdb_hr::StringTokenizer::StringToken& CommentToken{
      cdb_hr::IHybridRowSerializer::InitStringToken(Layout, CommentColumn.GetPath())
    };

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const EnumValue& value) noexcept;
    static cdb_hr::Result Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, EnumValue& value);
  };

  cdb_hr::Result EnumValueHybridRowSerializer::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, 
                   const cdb_hr::TypeArgumentList& typeArgs, const EnumValue& value) noexcept
  {
    if (isRoot)
    {
      return EnumValueHybridRowSerializer::Literal::Write(row, scope, value);
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.WriteScope(row, scope, Id);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    r = EnumValueHybridRowSerializer::Literal::Write(row, childScope, value);
    if (r != cdb_hr::Result::Success)
    {
      return r;
    }

    scope.Skip(row, childScope);
    return cdb_hr::Result::Success;
  }

  cdb_hr::Result EnumValueHybridRowSerializer::Literal::Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, const EnumValue& value) noexcept
  {
    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetValue()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Int64.WriteFixed(
        row, scope, ValueColumn, cdb_hr::IHybridRowSerializer::get(value.GetValue()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetName()))
    {
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteVariable(
        row, scope, NameColumn, cdb_hr::IHybridRowSerializer::get(value.GetName()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    if (!cdb_hr::IHybridRowSerializer::is_default(value.GetComment()))
    {
      scope.Find(row, CommentColumn.GetPath());
      cdb_hr::Result r = cdb_hr::LayoutLiteral::Utf8.WriteSparse(
        row, scope, cdb_hr::IHybridRowSerializer::get(value.GetComment()));
      if (r != cdb_hr::Result::Success)
      {
        return r;
      }
    }

    return cdb_hr::Result::Success;
  }

  std::tuple<cdb_hr::Result, std::unique_ptr<EnumValue>> EnumValueHybridRowSerializer::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot)
  {
    if (isRoot)
    {
      std::unique_ptr<EnumValue> value = std::make_unique<EnumValue>();
      cdb_hr::Result r = EnumValueHybridRowSerializer::Literal::Read(row, scope, *value);
      return {r, std::move(value)};
    }

    auto [r, childScope] = cdb_hr::LayoutLiteral::UDT.ReadScope(row, scope);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<EnumValue>{}};
    }

    std::unique_ptr<EnumValue> value = std::make_unique<EnumValue>();
    r = EnumValueHybridRowSerializer::Literal::Read(row, childScope, *value);
    if (r != cdb_hr::Result::Success)
    {
      return {r, std::unique_ptr<EnumValue>{}};
    }

    scope.Skip(row, childScope);
    return {cdb_hr::Result::Success, std::move(value)};
  }

  cdb_hr::Result EnumValueHybridRowSerializer::Literal::Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, EnumValue& value)
  {
    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Int64.ReadFixed(row, scope, ValueColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetValue(fieldValue);
        break;
      default:
        return r;
      }
    }

    {
      auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadVariable(row, scope, NameColumn);
      switch (r)
      {
      case cdb_hr::Result::NotFound:
        break;
      case cdb_hr::Result::Success:
        value.SetName(std::string(fieldValue));
        break;
      default:
        return r;
      }
    }

    while (scope.MoveNext(row))
    {
      if (scope.GetToken() == CommentToken.GetId())
      {
        auto [r, fieldValue] = cdb_hr::LayoutLiteral::Utf8.ReadSparse(row, scope);
        if (r != cdb_hr::Result::Success)
        {
          return r;
        }

        value.SetComment(std::move(fieldValue));
        continue;
      }
    }

    return cdb_hr::Result::Success;
  }
}
