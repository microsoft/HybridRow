// ------------------------------------------------------------
//  Copyright (c) Microsoft Corporation.  All rights reserved.
// ------------------------------------------------------------

#pragma once

// ------------------------------------------------------------
// This file was generated by:
//   Microsoft.Azure.Cosmos.Serialization.HybridRowCLI: 1.0.0.0
//
// This file should not be modified directly.
// ------------------------------------------------------------

namespace cdb_hr_test::typed_array
{
  class Tagged;
  class SimilarMatch;

  struct TypedArrayHrSchema final
  {
    static const cdb_hr::Namespace& GetNamespace() noexcept;
    static const cdb_hr::LayoutResolver& GetLayoutResolver() noexcept;

  private:
    class Literal;
  };

  class Tagged final
  {
  public:
    [[nodiscard]] const std::string& GetTitle() const noexcept { return m_title; }
    void SetTitle(std::string value) noexcept { m_title = std::move(value);}
    [[nodiscard]] const std::vector<std::string>& GetTags() const noexcept { return m_tags; }
    void SetTags(std::vector<std::string> value) noexcept { m_tags = std::move(value);}
    [[nodiscard]] const std::vector<std::optional<int32_t>>& GetOptions() const noexcept { return m_options; }
    void SetOptions(std::vector<std::optional<int32_t>> value) noexcept { m_options = std::move(value);}
    [[nodiscard]] const std::vector<std::vector<float64_t>>& GetRatings() const noexcept { return m_ratings; }
    void SetRatings(std::vector<std::vector<float64_t>> value) noexcept { m_ratings = std::move(value);}
    [[nodiscard]] const std::vector<std::unique_ptr<SimilarMatch>>& GetSimilars() const noexcept { return m_similars; }
    void SetSimilars(std::vector<std::unique_ptr<SimilarMatch>> value) noexcept { m_similars = std::move(value);}
    [[nodiscard]] const std::vector<std::tuple<std::string, int64_t>>& GetPriority() const noexcept { return m_priority; }
    void SetPriority(std::vector<std::tuple<std::string, int64_t>> value) noexcept { m_priority = std::move(value);}
  private:
    std::string m_title{};
    std::vector<std::string> m_tags{};
    std::vector<std::optional<int32_t>> m_options{};
    std::vector<std::vector<float64_t>> m_ratings{};
    std::vector<std::unique_ptr<SimilarMatch>> m_similars{};
    std::vector<std::tuple<std::string, int64_t>> m_priority{};
  };

  class SimilarMatch final
  {
  public:
    [[nodiscard]] const std::string& GetThumbprint() const noexcept { return m_thumbprint; }
    void SetThumbprint(std::string value) noexcept { m_thumbprint = std::move(value);}
    [[nodiscard]] float64_t GetScore() const noexcept { return m_score; }
    void SetScore(float64_t value) noexcept { m_score = std::move(value);}
  private:
    std::string m_thumbprint{};
    float64_t m_score{};
  };

  struct TaggedHybridRowSerializer final
  {
    using value_type = Tagged;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{1};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const Tagged& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<Tagged>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<Tagged, TaggedHybridRowSerializer>);

  struct SimilarMatchHybridRowSerializer final
  {
    using value_type = SimilarMatch;
    using owning_type = std::unique_ptr<value_type>;
    constexpr static cdb_hr::SchemaId Id{2};

    static cdb_hr::Result Write(cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot, const cdb_hr::TypeArgumentList& typeArgs,
      const SimilarMatch& value) noexcept;
    static std::tuple<cdb_hr::Result, std::unique_ptr<SimilarMatch>>
      Read(const cdb_hr::RowBuffer& row, cdb_hr::RowCursor& scope, bool isRoot);

  private:
    class Literal;
  };

  static_assert(cdb_hr::is_hybridrow_serializer_v<SimilarMatch, SimilarMatchHybridRowSerializer>);
}
